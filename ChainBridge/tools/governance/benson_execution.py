#!/usr/bin/env python3
"""
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
ğŸŸ¦ğŸŸ© BENSON EXECUTION RUNTIME
PAC-BENSON-P48-BENSON-EXECUTION-RUNTIME-AUTHORITY-AND-WRAP-GENERATION-01
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

PURPOSE:
    Authoritative execution runtime for all PAC operations.
    Only Benson (GID-00) may validate, sign, and finalize work.
    Agents produce EXECUTION_RESULT artifacts; Benson generates WRAPs.

AUTHORITY: BENSON (GID-00)
MODE: FAIL_CLOSED

INVARIANTS:
    - Only GID-00 may emit WRAP_ACCEPTED
    - Only GID-00 may advance PAC sequence
    - All agent work flows through this runtime
    - Raw agent output is EXECUTION_RESULT, not WRAP
    - WRAP only exists if generated by Benson

EXECUTION_LANE: EXECUTION_AUTHORITY
    Allowed Actions:
    - agent_activation
    - pac_execution
    - execution_validation
    - wrap_generation
    - wrap_acceptance
    - ledger_recording
    
    Forbidden Actions:
    - agent_self_closure
    - agent_wrap_emission
    - agent_authority_override

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
"""

import argparse
import hashlib
import json
import logging
import sys
from dataclasses import dataclass, field, asdict
from datetime import datetime, timezone, timedelta
from enum import Enum
from pathlib import Path
from typing import Optional, Any, Dict, List


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# EXECUTION TELEMETRY LOGGING (PAC-DAN-P53)
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

class TelemetryLogger:
    """
    Structured telemetry logger for Benson Execution Runtime.
    
    PAC Reference: PAC-DAN-P53-LIVE-GOVERNANCE-EXECUTION-TELEMETRY-01
    
    Emits structured JSON logs for all execution events:
    - PAC dispatch start/end
    - Agent execution start/end
    - Schema validation outcome
    - BER generation decision
    """
    
    def __init__(self, enable_stdout: bool = True, log_file: Optional[Path] = None):
        self.enable_stdout = enable_stdout
        self.log_file = log_file
        self._events: List[Dict[str, Any]] = []
        
        # Configure Python logger
        self.logger = logging.getLogger("benson_execution.telemetry")
        self.logger.setLevel(logging.DEBUG)
        
        if enable_stdout:
            handler = logging.StreamHandler(sys.stdout)
            handler.setFormatter(logging.Formatter('%(message)s'))
            self.logger.addHandler(handler)
    
    def emit(self, event_type: str, data: Dict[str, Any]) -> Dict[str, Any]:
        """
        Emit a structured telemetry event.
        
        Args:
            event_type: Type of event (PAC_DISPATCH_START, AGENT_EXEC_START, etc.)
            data: Event-specific data
        
        Returns:
            Complete telemetry event dict
        """
        event = {
            "telemetry_version": "1.0.0",
            "timestamp": datetime.now(timezone.utc).isoformat(),
            "event_type": event_type,
            "authority": "BENSON (GID-00)",
            "data": data
        }
        
        self._events.append(event)
        
        # Log as JSON
        if self.enable_stdout:
            self.logger.info(f"[TELEMETRY] {json.dumps(event)}")
        
        # Write to file if configured
        if self.log_file:
            try:
                with open(self.log_file, 'a') as f:
                    f.write(json.dumps(event) + "\n")
            except Exception:
                pass
        
        return event
    
    def pac_dispatch_start(self, pac_id: str, agent_gid: str, agent_name: str) -> Dict:
        """Log PAC dispatch start event."""
        return self.emit("PAC_DISPATCH_START", {
            "pac_id": pac_id,
            "agent_gid": agent_gid,
            "agent_name": agent_name,
            "phase": "DISPATCH"
        })
    
    def pac_dispatch_end(self, pac_id: str, status: str, duration_ms: int) -> Dict:
        """Log PAC dispatch end event."""
        return self.emit("PAC_DISPATCH_END", {
            "pac_id": pac_id,
            "status": status,
            "duration_ms": duration_ms,
            "phase": "DISPATCH_COMPLETE"
        })
    
    def agent_execution_start(self, pac_id: str, agent_gid: str) -> Dict:
        """Log agent execution start event."""
        return self.emit("AGENT_EXECUTION_START", {
            "pac_id": pac_id,
            "agent_gid": agent_gid,
            "phase": "EXECUTION"
        })
    
    def agent_execution_end(
        self,
        pac_id: str,
        agent_gid: str,
        status: str,
        tasks_completed: int,
        quality_score: float
    ) -> Dict:
        """Log agent execution end event."""
        return self.emit("AGENT_EXECUTION_END", {
            "pac_id": pac_id,
            "agent_gid": agent_gid,
            "status": status,
            "tasks_completed": tasks_completed,
            "quality_score": quality_score,
            "phase": "EXECUTION_COMPLETE"
        })
    
    def schema_validation(
        self,
        pac_id: str,
        schema_type: str,
        valid: bool,
        error_code: Optional[str] = None
    ) -> Dict:
        """Log schema validation outcome."""
        return self.emit("SCHEMA_VALIDATION", {
            "pac_id": pac_id,
            "schema_type": schema_type,
            "valid": valid,
            "error_code": error_code,
            "phase": "VALIDATION"
        })
    
    def ber_generation_decision(
        self,
        pac_id: str,
        eligible: bool,
        reason: str,
        human_review_required: bool
    ) -> Dict:
        """Log BER generation decision."""
        return self.emit("BER_GENERATION_DECISION", {
            "pac_id": pac_id,
            "eligible": eligible,
            "reason": reason,
            "human_review_required": human_review_required,
            "phase": "BER_DECISION"
        })
    
    def wrap_generation(
        self,
        pac_id: str,
        wrap_id: str,
        status: str,
        blocked: bool = False
    ) -> Dict:
        """Log WRAP generation event."""
        return self.emit("WRAP_GENERATION", {
            "pac_id": pac_id,
            "wrap_id": wrap_id,
            "status": status,
            "blocked": blocked,
            "phase": "WRAP"
        })
    
    def checkpoint(
        self,
        checkpoint_id: str,
        checkpoint_name: str,
        status: str,
        details: str
    ) -> Dict:
        """Log a validation checkpoint."""
        return self.emit("CHECKPOINT", {
            "checkpoint_id": checkpoint_id,
            "checkpoint_name": checkpoint_name,
            "status": status,
            "details": details,
            "phase": "CHECKPOINT"
        })
    
    def get_all_events(self) -> List[Dict[str, Any]]:
        """Return all logged telemetry events."""
        return self._events.copy()
    
    def get_telemetry_summary(self) -> Dict[str, Any]:
        """Generate summary of telemetry session."""
        return {
            "total_events": len(self._events),
            "event_types": list(set(e["event_type"] for e in self._events)),
            "first_event": self._events[0]["timestamp"] if self._events else None,
            "last_event": self._events[-1]["timestamp"] if self._events else None,
        }


# Module-level telemetry instance (singleton pattern)
_telemetry: Optional[TelemetryLogger] = None


def get_telemetry(enable_stdout: bool = False) -> TelemetryLogger:
    """Get or create telemetry logger instance."""
    global _telemetry
    if _telemetry is None:
        _telemetry = TelemetryLogger(enable_stdout=enable_stdout)
    return _telemetry


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# PATHS
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

SCRIPT_DIR = Path(__file__).parent
REPO_ROOT = SCRIPT_DIR.parent.parent
LEDGER_PATH = REPO_ROOT / "docs" / "governance" / "ledger" / "GOVERNANCE_LEDGER.json"
REGISTRY_PATH = REPO_ROOT / "docs" / "governance" / "AGENT_REGISTRY.json"
GOVERNANCE_RULES_PATH = REPO_ROOT / "docs" / "governance" / "governance_rules.json"
DOCTRINE_PATH = REPO_ROOT / "docs" / "governance" / "GOVERNANCE_DOCTRINE_V1.md"


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# ENUMS
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

class ExecutionStatus(Enum):
    """Status of PAC execution."""
    PENDING = "PENDING"
    EXECUTING = "EXECUTING"
    COMPLETED = "COMPLETED"
    FAILED = "FAILED"
    BLOCKED = "BLOCKED"


class WrapStatus(Enum):
    """Status of WRAP generation."""
    PENDING_VALIDATION = "PENDING_VALIDATION"
    VALIDATION_PASSED = "VALIDATION_PASSED"
    VALIDATION_FAILED = "VALIDATION_FAILED"
    WRAP_GENERATED = "WRAP_GENERATED"
    WRAP_ACCEPTED = "WRAP_ACCEPTED"
    WRAP_REJECTED = "WRAP_REJECTED"


class BlockReason(Enum):
    """Reasons for blocking execution."""
    AGENT_WRAP_EMISSION = "AGENT_WRAP_EMISSION"
    AGENT_SELF_CLOSURE = "AGENT_SELF_CLOSURE"
    UNAUTHORIZED_AUTHORITY = "UNAUTHORIZED_AUTHORITY"
    SCOPE_VIOLATION = "SCOPE_VIOLATION"
    LANE_VIOLATION = "LANE_VIOLATION"
    VALIDATION_FAILURE = "VALIDATION_FAILURE"
    EXECUTION_RESULT_SCHEMA_VIOLATION = "EXECUTION_RESULT_SCHEMA_VIOLATION"
    EXECUTION_RESULT_FORBIDDEN_FIELD = "EXECUTION_RESULT_FORBIDDEN_FIELD"
    # PAC-BENSON-P54: Dispatch authorization violations
    DISPATCH_NOT_AUTHORIZED = "DISPATCH_NOT_AUTHORIZED"  # GS_160
    DISPATCH_SESSION_MISMATCH = "DISPATCH_SESSION_MISMATCH"  # GS_161
    DISPATCH_EXPIRED = "DISPATCH_EXPIRED"  # GS_162
    # PAC-BENSON-P56: Self-evaluation violations
    SELF_APPROVAL_BLOCKED = "SELF_APPROVAL_BLOCKED"  # GS_173


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# EXECUTION ACCURACY HARDENING (PAC-BENSON-P56)
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

# Valid ground-truth sources for execution accuracy
VALID_GROUND_TRUTH_SOURCES = [
    "human_review_outcome",
    "override_decisions",
    "post_execution_failure_analysis",
    "external_validation",
]

# Invalid (self-referential) truth sources
INVALID_TRUTH_SOURCES = [
    "self_assessment",
    "model_confidence",
    "internal_scoring",
    "auto_generated",
]

# Forbidden fields in self-evaluation (GS_173/GS_174)
FORBIDDEN_SELF_EVAL_FIELDS = {
    "recommended_action": "GS_174",
    "corrective_steps": "GS_174",
    "improvement_plan": "GS_173",
    "self_approved": "GS_173",
    "action_proposal": "GS_174",
    "suggested_fix": "GS_174",
}

# Prescriptive language patterns forbidden in self-eval (GS_172)
PRESCRIPTIVE_PATTERNS = [
    r"\bshould\b",
    r"\bmust\b",
    r"\bneeds?\s+to\b",
    r"\brecommend\b",
    r"\bsuggest\b",
    r"\bpropose\b",
    r"\badvise\b",
    r"\brequire[sd]?\b",
]


def validate_ground_truth_sources(sources: List[str]) -> dict:
    """
    Validate that accuracy metrics use external ground-truth sources.
    
    PAC Reference: PAC-BENSON-P56-CORRECTIVE-EXECUTION-ACCURACY-HARDENING-01
    
    Args:
        sources: List of ground-truth source identifiers
    
    Returns:
        dict with 'valid', 'error_code', 'message', 'warnings'
    """
    warnings = []
    
    if not sources:
        return {
            "valid": False,
            "error_code": "GS_171",
            "message": "Missing ground-truth sources for accuracy metric",
            "warnings": [{
                "warning_code": "GS_171",
                "message": "Accuracy metrics must reference external ground-truth sources",
                "timestamp": datetime.now(timezone.utc).isoformat()
            }]
        }
    
    # Check for invalid (self-referential) sources
    for source in sources:
        if source in INVALID_TRUTH_SOURCES:
            return {
                "valid": False,
                "error_code": "GS_170",
                "message": f"Self-referential accuracy source detected: {source}",
                "warnings": [{
                    "warning_code": "GS_170",
                    "message": f"Cannot use self-generated truth signal: {source}",
                    "timestamp": datetime.now(timezone.utc).isoformat()
                }]
            }
    
    # Check all sources are valid
    invalid_sources = [s for s in sources if s not in VALID_GROUND_TRUTH_SOURCES]
    if invalid_sources:
        warnings.append({
            "warning_code": "GS_171",
            "message": f"Unrecognized ground-truth sources: {invalid_sources}",
            "timestamp": datetime.now(timezone.utc).isoformat()
        })
    
    return {
        "valid": True,
        "error_code": None,
        "message": "Ground-truth sources validated",
        "warnings": warnings
    }


def validate_self_eval_constraints(self_eval: dict) -> dict:
    """
    Validate self-evaluation output is descriptive-only (no prescriptive language).
    
    PAC Reference: PAC-BENSON-P56-CORRECTIVE-EXECUTION-ACCURACY-HARDENING-01
    
    Invariants:
        - Benson MAY evaluate performance
        - Benson MUST NOT prescribe corrective actions
        - Benson MUST NOT self-approve improvements
    
    Args:
        self_eval: Dictionary containing self-evaluation data
    
    Returns:
        dict with 'valid', 'error_code', 'message', 'warnings'
    """
    import re
    warnings = []
    
    # Check for forbidden fields (GS_173/GS_174)
    for field, error_code in FORBIDDEN_SELF_EVAL_FIELDS.items():
        if field in self_eval:
            # GS_173 is HARD_BLOCK (self-approval)
            if error_code == "GS_173":
                return {
                    "valid": False,
                    "error_code": error_code,
                    "message": f"Self-evaluation contains forbidden field: {field}. "
                               f"Self-approval of improvements is blocked.",
                    "warnings": []
                }
            # GS_174 is WARNING (corrective action recommendation)
            warnings.append({
                "warning_code": error_code,
                "message": f"Self-eval contains prescriptive field: {field}",
                "timestamp": datetime.now(timezone.utc).isoformat()
            })
    
    # Check for prescriptive language patterns (GS_172)
    text_fields = []
    for key, value in self_eval.items():
        if isinstance(value, str):
            text_fields.append(value)
        elif isinstance(value, list):
            text_fields.extend([v for v in value if isinstance(v, str)])
    
    combined_text = " ".join(text_fields).lower()
    
    for pattern in PRESCRIPTIVE_PATTERNS:
        if re.search(pattern, combined_text, re.IGNORECASE):
            warnings.append({
                "warning_code": "GS_172",
                "message": f"Prescriptive language detected: pattern '{pattern}'",
                "timestamp": datetime.now(timezone.utc).isoformat()
            })
    
    return {
        "valid": True,
        "error_code": None,
        "message": "Self-evaluation constraints validated",
        "warnings": warnings
    }


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# AGENT EXECUTION RESULT SCHEMA (PAC-DAN-P50)
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

# Required fields for AgentExecutionResult
REQUIRED_EXECUTION_RESULT_FIELDS = [
    "pac_id",
    "agent_gid",
    "agent_name",
    "execution_timestamp",
    "tasks_completed",
    "tasks_total",
    "files_modified",
    "quality_score",
    "scope_compliance",
    "execution_time_ms",
]

# Forbidden fields â€” agents cannot claim WRAP authority or self-close
FORBIDDEN_EXECUTION_RESULT_FIELDS = {
    # GS_131: WRAP field violations
    "wrap_id": "GS_131",
    "wrap_status": "GS_131",
    "wrap_accepted": "GS_131",
    # GS_132: Self-closure violations
    "positive_closure": "GS_132",
    "closure_authority": "GS_132",
    # GS_133: Authority violations
    "wrap_authority": "GS_133",
}


def validate_execution_result_schema(result: dict) -> dict:
    """
    Validate an AgentExecutionResult against the canonical schema.
    
    PAC Reference: PAC-DAN-P50-GOVERNANCE-EXECUTION-HANDOFF-AND-AGENT-RESULT-CONTRACT-01
    
    Args:
        result: Dictionary containing execution result data
    
    Returns:
        dict with 'valid', 'error_code', 'message', and optionally 'training_signal'
    """
    import re
    
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # CHECK 1: Forbidden fields (highest priority â€” blocks before other checks)
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    for forbidden_field, error_code in FORBIDDEN_EXECUTION_RESULT_FIELDS.items():
        if forbidden_field in result:
            return {
                "valid": False,
                "error_code": error_code,
                "message": f"AgentExecutionResult contains forbidden field '{forbidden_field}'. "
                           f"Agents cannot claim WRAP authority or self-close.",
                "training_signal": {
                    "pattern": "FORBIDDEN_FIELD_IN_EXECUTION_RESULT",
                    "lesson": f"Field '{forbidden_field}' is reserved for Benson (GID-00) only.",
                    "propagate": True
                }
            }
    
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # CHECK 2: Required fields
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    for required_field in REQUIRED_EXECUTION_RESULT_FIELDS:
        if required_field not in result:
            return {
                "valid": False,
                "error_code": "GS_130",
                "message": f"AgentExecutionResult missing required field: {required_field}"
            }
    
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # CHECK 3: Field type and value validation
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    # Validate agent_gid format (GID-XX)
    gid_pattern = r"^GID-\d{2}$"
    if not re.match(gid_pattern, result.get("agent_gid", "")):
        return {
            "valid": False,
            "error_code": "GS_130",
            "message": f"Invalid agent_gid format: {result.get('agent_gid')}. Expected GID-XX."
        }
    
    # Validate quality_score range (0.0-1.0)
    quality_score = result.get("quality_score", 0)
    if not isinstance(quality_score, (int, float)) or quality_score < 0.0 or quality_score > 1.0:
        return {
            "valid": False,
            "error_code": "GS_130",
            "message": f"Invalid quality_score: {quality_score}. Must be 0.0-1.0."
        }
    
    # Validate scope_compliance is boolean
    if not isinstance(result.get("scope_compliance"), bool):
        return {
            "valid": False,
            "error_code": "GS_130",
            "message": "scope_compliance must be a boolean value."
        }
    
    # Validate tasks_completed is list
    if not isinstance(result.get("tasks_completed"), list):
        return {
            "valid": False,
            "error_code": "GS_130",
            "message": "tasks_completed must be a list."
        }
    
    # Validate execution_time_ms is non-negative integer
    exec_time = result.get("execution_time_ms", -1)
    if not isinstance(exec_time, int) or exec_time < 0:
        return {
            "valid": False,
            "error_code": "GS_130",
            "message": f"Invalid execution_time_ms: {exec_time}. Must be non-negative integer."
        }
    
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # ALL CHECKS PASSED
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    return {
        "valid": True,
        "error_code": None,
        "message": "AgentExecutionResult schema validation passed."
    }


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# DATA STRUCTURES
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

@dataclass
class ExecutionResult:
    """
    Raw execution result from an agent.
    This is NOT a WRAP â€” it's input for Benson to validate and wrap.
    """
    pac_id: str
    agent_gid: str
    agent_name: str
    execution_timestamp: str
    tasks_completed: List[str]
    files_modified: List[str]
    quality_score: float
    scope_compliance: bool
    execution_time_ms: int
    notes: Optional[str] = None
    artifacts: Optional[Dict[str, Any]] = None


@dataclass
class WrapArtifact:
    """
    Canonical WRAP artifact â€” can ONLY be generated by Benson Execution.
    """
    wrap_id: str
    pac_id: str
    agent_gid: str
    agent_name: str
    wrap_hash: str
    pac_hash: str
    generated_at: str
    generated_by: str  # Always "BENSON (GID-00)"
    status: str
    quality_score: float
    scope_compliance: bool
    training_signal: Dict[str, Any]


@dataclass
class ValidationCheckpoint:
    """A single validation checkpoint in the execution pipeline."""
    checkpoint_id: str
    checkpoint_name: str
    status: str  # PASS | FAIL | ADVISORY
    details: str
    timestamp: str


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# EXECUTION DISPATCH AUTHORIZATION (PAC-BENSON-P54)
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

@dataclass
class ExecutionDispatchAuth:
    """
    Explicit dispatch authorization for agent execution.
    
    PAC Reference: PAC-BENSON-P54-AGENT-DISPATCH-EXECUTION-BINDING-01
    
    This artifact MUST be generated before any agent can execute.
    It binds a PAC â†’ Agent â†’ Execution Session.
    
    Key Invariants:
    - dispatch_session_id is unique per dispatch
    - Only Benson (GID-00) can generate dispatch authorizations
    - Agent execution without dispatch triggers FAIL_CLOSED
    - AgentExecutionResult MUST reference the dispatch_session_id
    
    Authority: BENSON (GID-00)
    Mode: FAIL_CLOSED
    """
    dispatch_id: str              # Unique identifier for this dispatch
    pac_id: str                   # PAC being dispatched
    agent_gid: str                # Agent authorized for execution
    agent_name: str               # Agent name for audit
    dispatch_session_id: str      # Unique session ID binding PAC â†’ Agent â†’ Execution
    dispatch_timestamp: str       # When dispatch was authorized
    authority_gid: str            # Must be GID-00 (Benson)
    authority_name: str           # Must be BENSON
    dispatch_hash: str            # Integrity hash of dispatch
    expires_at: Optional[str] = None  # Optional expiry (default: no expiry)
    notes: Optional[str] = None   # Optional notes for audit


# Dispatch authorization required fields for AgentExecutionResult (PAC-BENSON-P54)
DISPATCH_BINDING_FIELDS = [
    "execution_session_id",  # Must match dispatch_session_id
]


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# PDO (PROOFâ€“DECISIONâ€“OUTCOME) ARTIFACT (PAC-BENSON-P57)
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

class PDOStatus(Enum):
    """Status of PDO finalization."""
    PENDING = "PENDING"
    PROOF_VERIFIED = "PROOF_VERIFIED"
    DECISION_RECORDED = "DECISION_RECORDED"
    OUTCOME_FINALIZED = "OUTCOME_FINALIZED"
    FINALIZED = "FINALIZED"
    REJECTED = "REJECTED"


@dataclass
class BERApprovalState:
    """
    BER (Benson Execution Report) approval state for WRAP generation.
    
    PAC Reference: PAC-BENSON-P57-WRAP-AUTHORIZATION-AND-PDO-FINALIZATION-01
    
    Invariants:
        - human_review_completed MUST be True for WRAP generation
        - no_blocking_violations MUST be True (no GS_* HARD_BLOCK)
        - BER hash must be immutable after approval
    """
    ber_id: str
    pac_id: str
    agent_gid: str
    agent_name: str
    human_review_completed: bool
    human_review_timestamp: Optional[str]
    human_reviewer: Optional[str]
    no_blocking_violations: bool
    blocking_violations: List[str]  # List of GS_* codes if any
    ber_hash: str
    approval_timestamp: Optional[str] = None


@dataclass
class PDOArtifact:
    """
    Proofâ€“Decisionâ€“Outcome (PDO) artifact for immutable governance closure.
    
    PAC Reference: PAC-BENSON-P57-WRAP-AUTHORIZATION-AND-PDO-FINALIZATION-01
    
    Structure:
        - Proof: BER + WRAP hash binding
        - Decision: Authorization by BENSON (GID-00)
        - Outcome: Execution accepted/rejected
    
    Invariants:
        - PDO can ONLY be generated by Benson (GID-00)
        - PDO requires approved BER
        - PDO binds WRAP hash for immutability
        - PDO is recorded atomically to ledger
    
    Authority: BENSON (GID-00)
    Mode: FAIL_CLOSED
    """
    pdo_id: str
    pac_id: str
    ber_id: str
    wrap_id: str
    agent_gid: str
    agent_name: str
    
    # Proof component
    proof_ber_hash: str
    proof_wrap_hash: str
    proof_pac_hash: str
    proof_combined_hash: str  # SHA256(ber_hash + wrap_hash + pac_hash)
    
    # Decision component
    decision_authority: str  # Always "BENSON (GID-00)"
    decision_timestamp: str
    decision_type: str  # "AUTHORIZATION_GRANTED" | "AUTHORIZATION_DENIED"
    decision_rationale: str
    
    # Outcome component
    outcome_status: str  # "EXECUTION_ACCEPTED" | "EXECUTION_REJECTED"
    outcome_timestamp: str
    
    # Metadata
    status: str  # PDOStatus
    doctrine_hash: Optional[str] = None  # Hash of GOVERNANCE_DOCTRINE_V1
    rules_hash: Optional[str] = None  # Hash of governance_rules.json
    dispatch_session_id: Optional[str] = None  # From PAC-BENSON-P54
    
    # Training signal
    training_signal: Optional[Dict[str, Any]] = None


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# BENSON EXECUTION ENGINE
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

class BensonExecutionEngine:
    """
    Authoritative Execution Runtime for Governance.
    
    This is the ONLY valid runtime for PAC execution.
    All agent work must flow through here.
    WRAPs can ONLY be generated by this engine.
    
    Authority: BENSON (GID-00)
    Mode: FAIL_CLOSED
    
    PAC-BENSON-P51: Now loads governance rule registry for machine-enforceable law.
    PAC-DAN-P53: Now emits structured telemetry for execution events.
    PAC-BENSON-P54: Explicit dispatch authorization before execution.
    """
    
    AUTHORITY_GID = "GID-00"
    AUTHORITY_NAME = "BENSON"
    EXECUTION_LANE = "EXECUTION_AUTHORITY"
    VERSION = "1.3.0"  # Updated for P54 dispatch authorization
    
    def __init__(self, enable_telemetry: bool = True):
        self.ledger = self._load_ledger()
        self.governance_rules = self._load_governance_rules()
        self._execution_log: List[Dict[str, Any]] = []
        self.telemetry = TelemetryLogger(enable_stdout=enable_telemetry)
        # PAC-BENSON-P54: Track active dispatch authorizations
        self._active_dispatches: Dict[str, ExecutionDispatchAuth] = {}
    
    def _load_ledger(self):
        """Load governance ledger (lazy import to avoid circular deps)."""
        try:
            from ledger_writer import GovernanceLedger
            return GovernanceLedger(LEDGER_PATH)
        except ImportError:
            return None
    
    def _load_governance_rules(self) -> Dict[str, Any]:
        """
        Load governance rule registry (PAC-BENSON-P51).
        
        The rule registry provides machine-enforceable governance law.
        Rules are checked during validation and violation triggers
        the appropriate error code and training signal.
        """
        try:
            with open(GOVERNANCE_RULES_PATH, 'r') as f:
                rules_data = json.load(f)
                # Index rules by error code for fast lookup
                rules_data["_by_error_code"] = {
                    rule["error_code"]: rule 
                    for rule in rules_data.get("rules", [])
                }
                # Index rules by rule_id
                rules_data["_by_rule_id"] = {
                    rule["rule_id"]: rule 
                    for rule in rules_data.get("rules", [])
                }
                return rules_data
        except (FileNotFoundError, json.JSONDecodeError):
            # Return minimal structure if rules not available
            return {"rules": [], "_by_error_code": {}, "_by_rule_id": {}}
    
    def get_rule_by_error_code(self, error_code: str) -> Optional[Dict[str, Any]]:
        """Retrieve governance rule by error code."""
        return self.governance_rules.get("_by_error_code", {}).get(error_code)
    
    def get_rule_by_id(self, rule_id: str) -> Optional[Dict[str, Any]]:
        """Retrieve governance rule by rule ID."""
        return self.governance_rules.get("_by_rule_id", {}).get(rule_id)
    
    def get_training_signal_for_error(self, error_code: str) -> Optional[Dict[str, Any]]:
        """Get training signal from rule registry for an error code."""
        rule = self.get_rule_by_error_code(error_code)
        if rule and "training_signal" in rule:
            return {
                **rule["training_signal"],
                "rule_id": rule["rule_id"],
                "emitted_by": f"{self.AUTHORITY_NAME} ({self.AUTHORITY_GID})",
                "timestamp": datetime.now(timezone.utc).isoformat()
            }
        return None
    
    def _emit_training_signal(self, pattern: str, lesson: str, propagate: bool = True) -> Dict[str, Any]:
        """Generate a training signal for governance learning."""
        return {
            "pattern": pattern,
            "lesson": lesson,
            "propagate": propagate,
            "emitted_by": f"{self.AUTHORITY_NAME} ({self.AUTHORITY_GID})",
            "timestamp": datetime.now(timezone.utc).isoformat()
        }
    
    def _compute_hash(self, content: str) -> str:
        """Compute SHA256 hash for integrity verification."""
        return hashlib.sha256(content.encode('utf-8')).hexdigest()
    
    def _generate_session_id(self) -> str:
        """Generate a unique execution session ID (PAC-BENSON-P54)."""
        import uuid
        return f"SESS-{uuid.uuid4().hex[:16].upper()}"
    
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # DISPATCH AUTHORIZATION (PAC-BENSON-P54)
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    def dispatch_agent(
        self,
        pac_id: str,
        agent_gid: str,
        agent_name: str,
        notes: Optional[str] = None,
        expires_in_seconds: Optional[int] = None
    ) -> ExecutionDispatchAuth:
        """
        Create an explicit dispatch authorization for agent execution.
        
        PAC Reference: PAC-BENSON-P54-AGENT-DISPATCH-EXECUTION-BINDING-01
        
        This MUST be called before execute_pac_with_dispatch().
        Creates a unique execution_session_id binding PAC â†’ Agent.
        
        Args:
            pac_id: PAC being dispatched
            agent_gid: Agent authorized for execution
            agent_name: Agent name
            notes: Optional dispatch notes
            expires_in_seconds: Optional expiry time (default: no expiry)
        
        Returns:
            ExecutionDispatchAuth artifact
        
        Invariants:
            - Only Benson (GID-00) can generate dispatch authorizations
            - dispatch_session_id is globally unique
            - Dispatch is recorded to telemetry
        """
        timestamp = datetime.now(timezone.utc)
        dispatch_session_id = self._generate_session_id()
        
        # Compute expiry if specified
        expires_at = None
        if expires_in_seconds:
            expires_at = (timestamp + timedelta(seconds=expires_in_seconds)).isoformat()
        
        # Compute dispatch hash for integrity
        dispatch_content = json.dumps({
            "pac_id": pac_id,
            "agent_gid": agent_gid,
            "dispatch_session_id": dispatch_session_id,
            "dispatch_timestamp": timestamp.isoformat()
        }, sort_keys=True)
        dispatch_hash = self._compute_hash(dispatch_content)
        
        # Generate dispatch ID
        pac_num = self._extract_pac_number(pac_id)
        dispatch_id = f"DISPATCH-{agent_name.upper()}-P{pac_num}-{timestamp.strftime('%Y%m%d%H%M%S')}"
        
        dispatch = ExecutionDispatchAuth(
            dispatch_id=dispatch_id,
            pac_id=pac_id,
            agent_gid=agent_gid,
            agent_name=agent_name,
            dispatch_session_id=dispatch_session_id,
            dispatch_timestamp=timestamp.isoformat(),
            authority_gid=self.AUTHORITY_GID,
            authority_name=self.AUTHORITY_NAME,
            dispatch_hash=dispatch_hash,
            expires_at=expires_at,
            notes=notes
        )
        
        # Store active dispatch
        self._active_dispatches[dispatch_session_id] = dispatch
        
        # TELEMETRY: Dispatch Authorization (PAC-BENSON-P54)
        self.telemetry.emit("DISPATCH_AUTHORIZED", {
            "pac_id": pac_id,
            "agent_gid": agent_gid,
            "dispatch_session_id": dispatch_session_id,
            "dispatch_id": dispatch_id,
            "expires_at": expires_at
        })
        
        return dispatch
    
    def validate_dispatch(
        self,
        dispatch_session_id: str,
        pac_id: str,
        agent_gid: str
    ) -> Dict[str, Any]:
        """
        Validate a dispatch authorization before execution.
        
        PAC Reference: PAC-BENSON-P54-AGENT-DISPATCH-EXECUTION-BINDING-01
        
        Args:
            dispatch_session_id: Session ID from dispatch authorization
            pac_id: PAC being executed
            agent_gid: Agent attempting execution
        
        Returns:
            dict with 'valid', 'error_code', 'message', 'dispatch'
        """
        # Check if dispatch exists
        dispatch = self._active_dispatches.get(dispatch_session_id)
        if not dispatch:
            return {
                "valid": False,
                "error_code": "GS_160",
                "message": f"No dispatch authorization found for session {dispatch_session_id}. "
                           f"Agent execution without dispatch is blocked.",
                "dispatch": None,
                "training_signal": self._emit_training_signal(
                    pattern="DISPATCH_NOT_FOUND",
                    lesson="Agents must be explicitly dispatched before execution. "
                           "Use dispatch_agent() to create authorization.",
                    propagate=True
                )
            }
        
        # Check PAC ID matches
        if dispatch.pac_id != pac_id:
            return {
                "valid": False,
                "error_code": "GS_161",
                "message": f"Dispatch session {dispatch_session_id} is for PAC {dispatch.pac_id}, "
                           f"not {pac_id}. Session mismatch blocks execution.",
                "dispatch": dispatch,
                "training_signal": self._emit_training_signal(
                    pattern="DISPATCH_PAC_MISMATCH",
                    lesson="Dispatch authorization is bound to a specific PAC. "
                           "Cannot reuse dispatch for different PACs.",
                    propagate=True
                )
            }
        
        # Check agent GID matches
        if dispatch.agent_gid != agent_gid:
            return {
                "valid": False,
                "error_code": "GS_161",
                "message": f"Dispatch session {dispatch_session_id} is for agent {dispatch.agent_gid}, "
                           f"not {agent_gid}. Agent mismatch blocks execution.",
                "dispatch": dispatch,
                "training_signal": self._emit_training_signal(
                    pattern="DISPATCH_AGENT_MISMATCH",
                    lesson="Dispatch authorization is bound to a specific agent. "
                           "Cannot transfer dispatch between agents.",
                    propagate=True
                )
            }
        
        # Check expiry
        if dispatch.expires_at:
            expiry = datetime.fromisoformat(dispatch.expires_at.replace('Z', '+00:00'))
            if datetime.now(timezone.utc) > expiry:
                return {
                    "valid": False,
                    "error_code": "GS_162",
                    "message": f"Dispatch session {dispatch_session_id} expired at {dispatch.expires_at}. "
                               f"Expired dispatch blocks execution.",
                    "dispatch": dispatch,
                    "training_signal": self._emit_training_signal(
                        pattern="DISPATCH_EXPIRED",
                        lesson="Dispatch authorizations can have time limits. "
                               "Expired dispatches must be reissued.",
                        propagate=True
                    )
                }
        
        # All validations passed
        return {
            "valid": True,
            "error_code": None,
            "message": f"Dispatch authorization validated for {dispatch.agent_name} ({dispatch.agent_gid})",
            "dispatch": dispatch
        }
    
    def revoke_dispatch(self, dispatch_session_id: str) -> Dict[str, Any]:
        """
        Revoke a dispatch authorization.
        
        Called after execution completes or to cancel a dispatch.
        """
        dispatch = self._active_dispatches.pop(dispatch_session_id, None)
        if dispatch:
            self.telemetry.emit("DISPATCH_REVOKED", {
                "pac_id": dispatch.pac_id,
                "dispatch_session_id": dispatch_session_id,
                "reason": "EXECUTION_COMPLETE_OR_CANCELLED"
            })
            return {
                "revoked": True,
                "dispatch_session_id": dispatch_session_id,
                "pac_id": dispatch.pac_id
            }
        return {
            "revoked": False,
            "dispatch_session_id": dispatch_session_id,
            "message": "Dispatch not found or already revoked"
        }
    
    def get_active_dispatches(self) -> List[ExecutionDispatchAuth]:
        """Return all active dispatch authorizations."""
        return list(self._active_dispatches.values())
    
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # GATE 0: EXECUTION RESULT SCHEMA VALIDATION (PAC-DAN-P50)
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    def validate_execution_result_schema(self, result: dict) -> dict:
        """
        Validate an AgentExecutionResult against the canonical schema.
        
        Wrapper method that delegates to module-level function.
        Used by BensonExecutionEngine for pipeline validation.
        Emits telemetry for schema validation (PAC-DAN-P53).
        
        PAC Reference: PAC-DAN-P50-GOVERNANCE-EXECUTION-HANDOFF-AND-AGENT-RESULT-CONTRACT-01
        """
        validation_result = validate_execution_result_schema(result)
        
        # TELEMETRY: Schema Validation (PAC-DAN-P53)
        self.telemetry.schema_validation(
            pac_id=result.get("pac_id", "UNKNOWN"),
            schema_type="AgentExecutionResult",
            valid=validation_result["valid"],
            error_code=validation_result.get("error_code")
        )
        
        return validation_result
    
    def get_telemetry_for_ber(self) -> Dict[str, Any]:
        """
        Get telemetry data formatted for inclusion in Benson Execution Report.
        
        PAC Reference: PAC-DAN-P53-LIVE-GOVERNANCE-EXECUTION-TELEMETRY-01
        
        Returns:
            dict with telemetry summary and all events
        """
        return {
            "telemetry_version": "1.0.0",
            "summary": self.telemetry.get_telemetry_summary(),
            "events": self.telemetry.get_all_events()
        }
    
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # GATE 1: AGENT ACTIVATION VALIDATION
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    def validate_agent_activation(
        self,
        agent_gid: str,
        agent_name: str,
        lane: str
    ) -> Dict[str, Any]:
        """
        Validate that an agent is properly activated for execution.
        
        Returns:
            dict with 'valid', 'error_code', 'message'
        """
        # Load registry
        try:
            with open(REGISTRY_PATH, 'r') as f:
                registry = json.load(f)
        except FileNotFoundError:
            return {
                "valid": False,
                "error_code": "GS_117",
                "message": "Agent registry not found â€” activation blocked"
            }
        
        # Verify agent exists in registry
        # Registry format: {"agents": {"AGENT_NAME": {"gid": "GID-XX", ...}}}
        agents = registry.get("agents", {})
        agent_entry = None
        registry_agent_name = None
        
        # Search by GID in the agents dictionary
        for name, data in agents.items():
            if isinstance(data, dict) and data.get("gid") == agent_gid:
                agent_entry = data
                registry_agent_name = name
                break
        
        if not agent_entry:
            return {
                "valid": False,
                "error_code": "GS_117",
                "message": f"Agent {agent_gid} not found in registry â€” self-activation blocked"
            }
        
        # Verify agent name matches
        if registry_agent_name and registry_agent_name.upper() != agent_name.upper():
            return {
                "valid": False,
                "error_code": "GS_118",
                "message": f"Agent identity mismatch: {agent_name} vs registry {registry_agent_name}"
            }
        
        return {
            "valid": True,
            "error_code": None,
            "message": f"Agent {agent_name} ({agent_gid}) activation validated"
        }
    
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # GATE 2: PAC EXECUTION WITH DISPATCH (PAC-BENSON-P54)
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    def execute_pac_with_dispatch(
        self,
        dispatch_session_id: str,
        execution_result: ExecutionResult
    ) -> Dict[str, Any]:
        """
        Execute a PAC with explicit dispatch authorization.
        
        PAC Reference: PAC-BENSON-P54-AGENT-DISPATCH-EXECUTION-BINDING-01
        
        This is the PREFERRED execution method. It requires:
        1. A valid dispatch_session_id from dispatch_agent()
        2. An ExecutionResult with matching pac_id and agent_gid
        
        The execution_session_id is bound to the result for audit trail.
        
        Args:
            dispatch_session_id: Session ID from dispatch_agent()
            execution_result: Raw execution output from agent
        
        Returns:
            dict with execution status, validation results, dispatch binding, and WRAP if generated
        
        Invariants:
            - Execution without dispatch triggers FAIL_CLOSED (GS_150)
            - Session mismatch triggers FAIL_CLOSED (GS_151)
            - Expired dispatch triggers FAIL_CLOSED (GS_152)
        """
        timestamp = datetime.now(timezone.utc).isoformat()
        dispatch_start = datetime.now(timezone.utc)
        
        pac_id = execution_result.pac_id
        agent_gid = execution_result.agent_gid
        agent_name = execution_result.agent_name
        
        # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        # CHECKPOINT 0: DISPATCH AUTHORIZATION VALIDATION (PAC-BENSON-P54)
        # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        dispatch_validation = self.validate_dispatch(dispatch_session_id, pac_id, agent_gid)
        
        if not dispatch_validation["valid"]:
            # TELEMETRY: Dispatch Validation Failed
            self.telemetry.emit("DISPATCH_VALIDATION_FAILED", {
                "pac_id": pac_id,
                "agent_gid": agent_gid,
                "dispatch_session_id": dispatch_session_id,
                "error_code": dispatch_validation["error_code"],
                "message": dispatch_validation["message"]
            })
            
            # Determine block reason based on error code
            if dispatch_validation["error_code"] == "GS_160":
                block_reason = BlockReason.DISPATCH_NOT_AUTHORIZED
            elif dispatch_validation["error_code"] == "GS_161":
                block_reason = BlockReason.DISPATCH_SESSION_MISMATCH
            else:
                block_reason = BlockReason.DISPATCH_EXPIRED
            
            return {
                "pac_id": pac_id,
                "agent_gid": agent_gid,
                "agent_name": agent_name,
                "dispatch_session_id": dispatch_session_id,
                "status": ExecutionStatus.BLOCKED.value,
                "block_reason": block_reason.value,
                "error_code": dispatch_validation["error_code"],
                "message": dispatch_validation["message"],
                "training_signal": dispatch_validation.get("training_signal"),
                "checkpoints": [],
                "wrap": None,
                "telemetry": self.telemetry.get_all_events()
            }
        
        dispatch = dispatch_validation["dispatch"]
        
        # TELEMETRY: PAC Dispatch Start with Session Binding
        self.telemetry.emit("PAC_DISPATCH_START_WITH_SESSION", {
            "pac_id": pac_id,
            "agent_gid": agent_gid,
            "agent_name": agent_name,
            "dispatch_session_id": dispatch_session_id,
            "dispatch_id": dispatch.dispatch_id
        })
        
        # Initialize execution record with dispatch binding
        execution_record = {
            "pac_id": pac_id,
            "agent_gid": agent_gid,
            "agent_name": agent_name,
            "dispatch_session_id": dispatch_session_id,
            "dispatch_id": dispatch.dispatch_id,
            "execution_start": timestamp,
            "status": ExecutionStatus.EXECUTING.value,
            "checkpoints": [],
            "wrap": None,
            "telemetry": []
        }
        
        # TELEMETRY: Agent Execution Start
        self.telemetry.agent_execution_start(pac_id, agent_gid)
        
        # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        # CHECKPOINT 1: Agent Activation Validation
        # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        activation_result = self.validate_agent_activation(agent_gid, agent_name, self.EXECUTION_LANE)
        cp1 = ValidationCheckpoint(
            checkpoint_id="CP-01",
            checkpoint_name="AGENT_ACTIVATION_VALIDATION",
            status="PASS" if activation_result["valid"] else "FAIL",
            details=activation_result["message"],
            timestamp=datetime.now(timezone.utc).isoformat()
        )
        execution_record["checkpoints"].append(cp1)
        self.telemetry.checkpoint(cp1.checkpoint_id, cp1.checkpoint_name, cp1.status, cp1.details)
        
        if not activation_result["valid"]:
            execution_record["status"] = ExecutionStatus.BLOCKED.value
            execution_record["block_reason"] = BlockReason.UNAUTHORIZED_AUTHORITY.value
            duration_ms = int((datetime.now(timezone.utc) - dispatch_start).total_seconds() * 1000)
            self.telemetry.pac_dispatch_end(pac_id, "BLOCKED", duration_ms)
            execution_record["telemetry"] = self.telemetry.get_all_events()
            self._execution_log.append(execution_record)
            return execution_record
        
        # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        # CHECKPOINT 2: Scope Compliance Validation
        # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        scope_valid = execution_result.scope_compliance
        cp2 = ValidationCheckpoint(
            checkpoint_id="CP-02",
            checkpoint_name="SCOPE_COMPLIANCE_VALIDATION",
            status="PASS" if scope_valid else "FAIL",
            details="Scope compliance verified" if scope_valid else "Scope violation detected",
            timestamp=datetime.now(timezone.utc).isoformat()
        )
        execution_record["checkpoints"].append(cp2)
        self.telemetry.checkpoint(cp2.checkpoint_id, cp2.checkpoint_name, cp2.status, cp2.details)
        
        if not scope_valid:
            execution_record["status"] = ExecutionStatus.BLOCKED.value
            execution_record["block_reason"] = BlockReason.SCOPE_VIOLATION.value
            duration_ms = int((datetime.now(timezone.utc) - dispatch_start).total_seconds() * 1000)
            self.telemetry.pac_dispatch_end(pac_id, "BLOCKED", duration_ms)
            execution_record["telemetry"] = self.telemetry.get_all_events()
            self._execution_log.append(execution_record)
            return execution_record
        
        # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        # CHECKPOINT 3: Quality Score Validation
        # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        quality_threshold = 0.7
        quality_valid = execution_result.quality_score >= quality_threshold
        cp3 = ValidationCheckpoint(
            checkpoint_id="CP-03",
            checkpoint_name="QUALITY_SCORE_VALIDATION",
            status="PASS" if quality_valid else "FAIL",
            details=f"Quality score: {execution_result.quality_score} (threshold: {quality_threshold})",
            timestamp=datetime.now(timezone.utc).isoformat()
        )
        execution_record["checkpoints"].append(cp3)
        self.telemetry.checkpoint(cp3.checkpoint_id, cp3.checkpoint_name, cp3.status, cp3.details)
        
        if not quality_valid:
            execution_record["status"] = ExecutionStatus.FAILED.value
            execution_record["block_reason"] = BlockReason.VALIDATION_FAILURE.value
            duration_ms = int((datetime.now(timezone.utc) - dispatch_start).total_seconds() * 1000)
            self.telemetry.pac_dispatch_end(pac_id, "FAILED", duration_ms)
            execution_record["telemetry"] = self.telemetry.get_all_events()
            self._execution_log.append(execution_record)
            return execution_record
        
        # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        # CHECKPOINT 4: Task Completion Validation
        # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        tasks_complete = len(execution_result.tasks_completed) > 0
        cp4 = ValidationCheckpoint(
            checkpoint_id="CP-04",
            checkpoint_name="TASK_COMPLETION_VALIDATION",
            status="PASS" if tasks_complete else "FAIL",
            details=f"Tasks completed: {len(execution_result.tasks_completed)}",
            timestamp=datetime.now(timezone.utc).isoformat()
        )
        execution_record["checkpoints"].append(cp4)
        self.telemetry.checkpoint(cp4.checkpoint_id, cp4.checkpoint_name, cp4.status, cp4.details)
        
        if not tasks_complete:
            execution_record["status"] = ExecutionStatus.FAILED.value
            execution_record["block_reason"] = BlockReason.VALIDATION_FAILURE.value
            duration_ms = int((datetime.now(timezone.utc) - dispatch_start).total_seconds() * 1000)
            self.telemetry.pac_dispatch_end(pac_id, "FAILED", duration_ms)
            execution_record["telemetry"] = self.telemetry.get_all_events()
            self._execution_log.append(execution_record)
            return execution_record
        
        # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        # TELEMETRY: Agent Execution End
        # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        self.telemetry.agent_execution_end(
            pac_id=pac_id,
            agent_gid=agent_gid,
            status="COMPLETED",
            tasks_completed=len(execution_result.tasks_completed),
            quality_score=execution_result.quality_score
        )
        
        # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        # TELEMETRY: BER Generation Decision
        # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        self.telemetry.ber_generation_decision(
            pac_id=pac_id,
            eligible=True,
            reason="All checkpoints passed",
            human_review_required=False
        )
        
        # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        # ALL CHECKPOINTS PASSED â€” GENERATE WRAP (with dispatch binding)
        # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        execution_record["status"] = ExecutionStatus.COMPLETED.value
        
        # Generate canonical WRAP with dispatch binding
        wrap = self._generate_wrap_with_dispatch(
            pac_id=pac_id,
            agent_gid=agent_gid,
            agent_name=agent_name,
            execution_result=execution_result,
            dispatch=dispatch
        )
        execution_record["wrap"] = wrap
        
        # TELEMETRY: WRAP Generation with Dispatch
        self.telemetry.emit("WRAP_GENERATED_WITH_DISPATCH", {
            "pac_id": pac_id,
            "wrap_id": wrap.wrap_id,
            "dispatch_session_id": dispatch_session_id,
            "status": "WRAP_GENERATED"
        })
        
        # Record to ledger
        if self.ledger:
            try:
                self.ledger.record_wrap_accepted(
                    artifact_id=wrap.wrap_id,
                    agent_gid=agent_gid,
                    agent_name=agent_name,
                    ratified_by=f"{self.AUTHORITY_NAME} ({self.AUTHORITY_GID})",
                    notes=f"PAC: {pac_id}, Session: {dispatch_session_id}, Quality: {execution_result.quality_score}"
                )
            except Exception as e:
                print(f"âš  Ledger write failed: {e}")
        
        # Revoke dispatch after successful execution
        self.revoke_dispatch(dispatch_session_id)
        
        # TELEMETRY: PAC Dispatch End
        duration_ms = int((datetime.now(timezone.utc) - dispatch_start).total_seconds() * 1000)
        self.telemetry.pac_dispatch_end(pac_id, "COMPLETED", duration_ms)
        execution_record["telemetry"] = self.telemetry.get_all_events()
        
        self._execution_log.append(execution_record)
        return execution_record
    
    def _generate_wrap_with_dispatch(
        self,
        pac_id: str,
        agent_gid: str,
        agent_name: str,
        execution_result: ExecutionResult,
        dispatch: ExecutionDispatchAuth
    ) -> WrapArtifact:
        """
        Generate a canonical WRAP artifact with dispatch binding.
        
        PAC Reference: PAC-BENSON-P54-AGENT-DISPATCH-EXECUTION-BINDING-01
        
        This extends _generate_wrap to include dispatch_session_id in the
        wrap hash for full audit binding.
        """
        timestamp = datetime.now(timezone.utc).isoformat()
        
        # Generate WRAP ID
        pac_number = self._extract_pac_number(pac_id)
        wrap_id = f"WRAP-{agent_name.upper()}-P{pac_number}-{timestamp[:10].replace('-', '')}"
        
        # Compute hashes for integrity binding (including dispatch)
        pac_hash = self._compute_hash(pac_id)
        wrap_content = json.dumps({
            "wrap_id": wrap_id,
            "pac_id": pac_id,
            "agent_gid": agent_gid,
            "dispatch_session_id": dispatch.dispatch_session_id,  # PAC-BENSON-P54
            "dispatch_id": dispatch.dispatch_id,  # PAC-BENSON-P54
            "tasks": execution_result.tasks_completed,
            "quality_score": execution_result.quality_score
        }, sort_keys=True)
        wrap_hash = self._compute_hash(wrap_content)
        
        # Generate training signal
        training_signal = self._emit_training_signal(
            pattern="EXECUTION_REQUIRES_DISPATCH_AND_AUTHORITY",
            lesson="Dispatch authorization binds PAC â†’ Agent â†’ Session. Only Benson may validate and finalize.",
            propagate=True
        )
        
        return WrapArtifact(
            wrap_id=wrap_id,
            pac_id=pac_id,
            agent_gid=agent_gid,
            agent_name=agent_name,
            wrap_hash=wrap_hash,
            pac_hash=pac_hash,
            generated_at=timestamp,
            generated_by=f"{self.AUTHORITY_NAME} ({self.AUTHORITY_GID})",
            status=WrapStatus.WRAP_GENERATED.value,
            quality_score=execution_result.quality_score,
            scope_compliance=execution_result.scope_compliance,
            training_signal=training_signal
        )
    
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # GATE 2 (LEGACY): PAC EXECUTION INTERCEPTION
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    def execute_pac(
        self,
        pac_id: str,
        agent_gid: str,
        agent_name: str,
        execution_result: ExecutionResult
    ) -> Dict[str, Any]:
        """
        Execute a PAC under Benson authority (LEGACY METHOD).
        
        âš ï¸ DEPRECATION NOTICE (PAC-BENSON-P54):
        This method does NOT enforce dispatch authorization.
        Prefer execute_pac_with_dispatch() for new code.
        
        All PAC execution MUST flow through this method.
        Raw agent output is captured as EXECUTION_RESULT.
        WRAP is generated ONLY if validation passes.
        
        Args:
            pac_id: The PAC being executed
            agent_gid: Agent performing the work
            agent_name: Agent name
            execution_result: Raw execution output from agent
        
        Returns:
            dict with execution status, validation results, and WRAP if generated
        """
        timestamp = datetime.now(timezone.utc).isoformat()
        dispatch_start = datetime.now(timezone.utc)
        
        # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        # TELEMETRY: PAC Dispatch Start (PAC-DAN-P53)
        # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        self.telemetry.pac_dispatch_start(pac_id, agent_gid, agent_name)
        
        # Initialize execution record
        execution_record = {
            "pac_id": pac_id,
            "agent_gid": agent_gid,
            "agent_name": agent_name,
            "execution_start": timestamp,
            "status": ExecutionStatus.EXECUTING.value,
            "checkpoints": [],
            "wrap": None,
            "telemetry": []  # Collect telemetry events for BER
        }
        
        # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        # TELEMETRY: Agent Execution Start (PAC-DAN-P53)
        # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        self.telemetry.agent_execution_start(pac_id, agent_gid)
        
        # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        # CHECKPOINT 1: Agent Activation Validation
        # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        activation_result = self.validate_agent_activation(agent_gid, agent_name, self.EXECUTION_LANE)
        cp1 = ValidationCheckpoint(
            checkpoint_id="CP-01",
            checkpoint_name="AGENT_ACTIVATION_VALIDATION",
            status="PASS" if activation_result["valid"] else "FAIL",
            details=activation_result["message"],
            timestamp=datetime.now(timezone.utc).isoformat()
        )
        execution_record["checkpoints"].append(cp1)
        self.telemetry.checkpoint(cp1.checkpoint_id, cp1.checkpoint_name, cp1.status, cp1.details)
        
        if not activation_result["valid"]:
            execution_record["status"] = ExecutionStatus.BLOCKED.value
            execution_record["block_reason"] = BlockReason.UNAUTHORIZED_AUTHORITY.value
            # TELEMETRY: Dispatch End (failed)
            duration_ms = int((datetime.now(timezone.utc) - dispatch_start).total_seconds() * 1000)
            self.telemetry.pac_dispatch_end(pac_id, "BLOCKED", duration_ms)
            execution_record["telemetry"] = self.telemetry.get_all_events()
            self._execution_log.append(execution_record)
            return execution_record
        
        # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        # CHECKPOINT 2: Scope Compliance Validation
        # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        scope_valid = execution_result.scope_compliance
        cp2 = ValidationCheckpoint(
            checkpoint_id="CP-02",
            checkpoint_name="SCOPE_COMPLIANCE_VALIDATION",
            status="PASS" if scope_valid else "FAIL",
            details="Scope compliance verified" if scope_valid else "Scope violation detected",
            timestamp=datetime.now(timezone.utc).isoformat()
        )
        execution_record["checkpoints"].append(cp2)
        self.telemetry.checkpoint(cp2.checkpoint_id, cp2.checkpoint_name, cp2.status, cp2.details)
        
        if not scope_valid:
            execution_record["status"] = ExecutionStatus.BLOCKED.value
            execution_record["block_reason"] = BlockReason.SCOPE_VIOLATION.value
            duration_ms = int((datetime.now(timezone.utc) - dispatch_start).total_seconds() * 1000)
            self.telemetry.pac_dispatch_end(pac_id, "BLOCKED", duration_ms)
            execution_record["telemetry"] = self.telemetry.get_all_events()
            self._execution_log.append(execution_record)
            return execution_record
        
        # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        # CHECKPOINT 3: Quality Score Validation
        # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        quality_threshold = 0.7  # Minimum quality score for WRAP generation
        quality_valid = execution_result.quality_score >= quality_threshold
        cp3 = ValidationCheckpoint(
            checkpoint_id="CP-03",
            checkpoint_name="QUALITY_SCORE_VALIDATION",
            status="PASS" if quality_valid else "FAIL",
            details=f"Quality score: {execution_result.quality_score} (threshold: {quality_threshold})",
            timestamp=datetime.now(timezone.utc).isoformat()
        )
        execution_record["checkpoints"].append(cp3)
        self.telemetry.checkpoint(cp3.checkpoint_id, cp3.checkpoint_name, cp3.status, cp3.details)
        
        if not quality_valid:
            execution_record["status"] = ExecutionStatus.FAILED.value
            execution_record["block_reason"] = BlockReason.VALIDATION_FAILURE.value
            duration_ms = int((datetime.now(timezone.utc) - dispatch_start).total_seconds() * 1000)
            self.telemetry.pac_dispatch_end(pac_id, "FAILED", duration_ms)
            execution_record["telemetry"] = self.telemetry.get_all_events()
            self._execution_log.append(execution_record)
            return execution_record
        
        # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        # CHECKPOINT 4: Task Completion Validation
        # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        tasks_complete = len(execution_result.tasks_completed) > 0
        cp4 = ValidationCheckpoint(
            checkpoint_id="CP-04",
            checkpoint_name="TASK_COMPLETION_VALIDATION",
            status="PASS" if tasks_complete else "FAIL",
            details=f"Tasks completed: {len(execution_result.tasks_completed)}",
            timestamp=datetime.now(timezone.utc).isoformat()
        )
        execution_record["checkpoints"].append(cp4)
        self.telemetry.checkpoint(cp4.checkpoint_id, cp4.checkpoint_name, cp4.status, cp4.details)
        
        if not tasks_complete:
            execution_record["status"] = ExecutionStatus.FAILED.value
            execution_record["block_reason"] = BlockReason.VALIDATION_FAILURE.value
            duration_ms = int((datetime.now(timezone.utc) - dispatch_start).total_seconds() * 1000)
            self.telemetry.pac_dispatch_end(pac_id, "FAILED", duration_ms)
            execution_record["telemetry"] = self.telemetry.get_all_events()
            self._execution_log.append(execution_record)
            return execution_record
        
        # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        # TELEMETRY: Agent Execution End (PAC-DAN-P53)
        # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        self.telemetry.agent_execution_end(
            pac_id=pac_id,
            agent_gid=agent_gid,
            status="COMPLETED",
            tasks_completed=len(execution_result.tasks_completed),
            quality_score=execution_result.quality_score
        )
        
        # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        # TELEMETRY: BER Generation Decision (PAC-DAN-P53)
        # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        self.telemetry.ber_generation_decision(
            pac_id=pac_id,
            eligible=True,
            reason="All checkpoints passed",
            human_review_required=False  # Auto-WRAP path
        )
        
        # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        # ALL CHECKPOINTS PASSED â€” GENERATE WRAP
        # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        execution_record["status"] = ExecutionStatus.COMPLETED.value
        
        # Generate canonical WRAP
        wrap = self._generate_wrap(pac_id, agent_gid, agent_name, execution_result)
        execution_record["wrap"] = wrap
        
        # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        # TELEMETRY: WRAP Generation (PAC-DAN-P53)
        # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        self.telemetry.wrap_generation(
            pac_id=pac_id,
            wrap_id=wrap.wrap_id,
            status="WRAP_GENERATED",
            blocked=False
        )
        
        # Record to ledger
        if self.ledger:
            try:
                self.ledger.record_wrap_accepted(
                    artifact_id=wrap.wrap_id,
                    agent_gid=agent_gid,
                    agent_name=agent_name,
                    ratified_by=f"{self.AUTHORITY_NAME} ({self.AUTHORITY_GID})",
                    notes=f"PAC: {pac_id}, Quality: {execution_result.quality_score}"
                )
            except Exception as e:
                print(f"âš  Ledger write failed: {e}")
        
        # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        # TELEMETRY: PAC Dispatch End (PAC-DAN-P53)
        # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        duration_ms = int((datetime.now(timezone.utc) - dispatch_start).total_seconds() * 1000)
        self.telemetry.pac_dispatch_end(pac_id, "COMPLETED", duration_ms)
        execution_record["telemetry"] = self.telemetry.get_all_events()
        
        self._execution_log.append(execution_record)
        return execution_record
    
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # WRAP GENERATION (BENSON-ONLY)
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    def _generate_wrap(
        self,
        pac_id: str,
        agent_gid: str,
        agent_name: str,
        execution_result: ExecutionResult
    ) -> WrapArtifact:
        """
        Generate a canonical WRAP artifact.
        
        This method can ONLY be called internally by Benson Execution.
        External callers cannot generate WRAPs.
        """
        timestamp = datetime.now(timezone.utc).isoformat()
        
        # Generate WRAP ID
        pac_number = self._extract_pac_number(pac_id)
        wrap_id = f"WRAP-{agent_name.upper()}-P{pac_number}-{timestamp[:10].replace('-', '')}"
        
        # Compute hashes for integrity binding
        pac_hash = self._compute_hash(pac_id)
        wrap_content = json.dumps({
            "wrap_id": wrap_id,
            "pac_id": pac_id,
            "agent_gid": agent_gid,
            "tasks": execution_result.tasks_completed,
            "quality_score": execution_result.quality_score
        }, sort_keys=True)
        wrap_hash = self._compute_hash(wrap_content)
        
        # Generate training signal
        training_signal = self._emit_training_signal(
            pattern="EXECUTION_REQUIRES_AUTHORITY",
            lesson="Only Benson may validate, sign, and finalize work",
            propagate=True
        )
        
        return WrapArtifact(
            wrap_id=wrap_id,
            pac_id=pac_id,
            agent_gid=agent_gid,
            agent_name=agent_name,
            wrap_hash=wrap_hash,
            pac_hash=pac_hash,
            generated_at=timestamp,
            generated_by=f"{self.AUTHORITY_NAME} ({self.AUTHORITY_GID})",
            status=WrapStatus.WRAP_GENERATED.value,
            quality_score=execution_result.quality_score,
            scope_compliance=execution_result.scope_compliance,
            training_signal=training_signal
        )
    
    def _extract_pac_number(self, pac_id: str) -> int:
        """Extract PAC number from PAC ID."""
        import re
        match = re.search(r'-P(\d+)-', pac_id)
        if match:
            return int(match.group(1))
        return 0
    
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # HARD BLOCKS â€” AGENT WRAP EMISSION PREVENTION
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    def block_agent_wrap_emission(
        self,
        agent_gid: str,
        agent_name: str,
        attempted_action: str
    ) -> Dict[str, Any]:
        """
        Hard-block any attempt by an agent to emit a WRAP directly.
        
        This enforces PAC-BENSON-P48: Agents cannot emit WRAP_ACCEPTED.
        Agent work is treated as EXECUTION_RESULT, not WRAP.
        """
        timestamp = datetime.now(timezone.utc).isoformat()
        
        block_record = {
            "block_type": "AGENT_WRAP_EMISSION_BLOCKED",
            "error_code": "GS_121",
            "timestamp": timestamp,
            "agent_gid": agent_gid,
            "agent_name": agent_name,
            "attempted_action": attempted_action,
            "authority": f"{self.AUTHORITY_NAME} ({self.AUTHORITY_GID})",
            "message": "Agents cannot emit WRAPs directly. Use EXECUTION_RESULT.",
            "training_signal": self._emit_training_signal(
                pattern="AGENT_WRAP_EMISSION_BLOCKED",
                lesson="Agent output is EXECUTION_RESULT, not WRAP. Only Benson generates WRAPs.",
                propagate=True
            )
        }
        
        # Record to ledger as learning event
        if self.ledger:
            try:
                self.ledger.record_block_enforced(
                    artifact_id=f"BLOCK-{timestamp}",
                    agent_gid=agent_gid,
                    agent_name=agent_name,
                    pac_id="RUNTIME_ENFORCEMENT",
                    authority_gid=self.AUTHORITY_GID,
                    error_codes=["GS_121"],
                    training_signal=block_record["training_signal"]
                )
            except Exception:
                pass
        
        return block_record
    
    def block_agent_self_closure(
        self,
        agent_gid: str,
        agent_name: str
    ) -> Dict[str, Any]:
        """
        Hard-block any attempt by an agent to declare POSITIVE_CLOSURE.
        
        Only Benson may declare POSITIVE_CLOSURE.
        """
        timestamp = datetime.now(timezone.utc).isoformat()
        
        block_record = {
            "block_type": "AGENT_SELF_CLOSURE_BLOCKED",
            "error_code": "GS_124",
            "timestamp": timestamp,
            "agent_gid": agent_gid,
            "agent_name": agent_name,
            "authority": f"{self.AUTHORITY_NAME} ({self.AUTHORITY_GID})",
            "message": "Agents cannot declare POSITIVE_CLOSURE. Only Benson may close work.",
            "training_signal": self._emit_training_signal(
                pattern="AGENT_SELF_CLOSURE_BLOCKED",
                lesson="POSITIVE_CLOSURE requires Benson authority. Agents submit results for validation.",
                propagate=True
            )
        }
        
        return block_record

    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # WRAP AUTHORIZATION & PDO FINALIZATION (PAC-BENSON-P57)
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    def validate_ber_approval(
        self,
        ber_id: str,
        pac_id: str,
        agent_gid: str,
        agent_name: str,
        ber_data: Dict[str, Any]
    ) -> BERApprovalState:
        """
        Validate BER approval state for WRAP generation eligibility.
        
        PAC Reference: PAC-BENSON-P57-WRAP-AUTHORIZATION-AND-PDO-FINALIZATION-01
        
        Args:
            ber_id: BER artifact identifier
            pac_id: Associated PAC identifier
            agent_gid: Agent GID
            agent_name: Agent name
            ber_data: BER content dictionary
        
        Returns:
            BERApprovalState with validation results
        
        Invariants:
            - Human review MUST be completed
            - No blocking GS_* violations present
            - BER hash is computed for immutability binding
        """
        timestamp = datetime.now(timezone.utc)
        
        # Check human review status
        human_review_completed = ber_data.get("human_review_completed", False)
        human_review_timestamp = ber_data.get("human_review_timestamp")
        human_reviewer = ber_data.get("human_reviewer")
        
        # Check for blocking violations
        violations = ber_data.get("violations", [])
        blocking_violations = []
        
        for violation in violations:
            code = violation.get("error_code", "")
            severity = violation.get("severity", "WARNING")
            # GS_173 is HARD_BLOCK, others may be WARNING
            if severity == "HARD_BLOCK" or code == "GS_173":
                blocking_violations.append(code)
        
        no_blocking_violations = len(blocking_violations) == 0
        
        # Compute BER hash
        ber_content = json.dumps(ber_data, sort_keys=True, separators=(',', ':'))
        ber_hash = self._compute_hash(ber_content)
        
        # Set approval timestamp if approved
        approval_timestamp = None
        if human_review_completed and no_blocking_violations:
            approval_timestamp = timestamp.isoformat()
        
        return BERApprovalState(
            ber_id=ber_id,
            pac_id=pac_id,
            agent_gid=agent_gid,
            agent_name=agent_name,
            human_review_completed=human_review_completed,
            human_review_timestamp=human_review_timestamp,
            human_reviewer=human_reviewer,
            no_blocking_violations=no_blocking_violations,
            blocking_violations=blocking_violations,
            ber_hash=ber_hash,
            approval_timestamp=approval_timestamp
        )
    
    def authorize_wrap_from_ber(
        self,
        ber_approval: BERApprovalState,
        execution_result: ExecutionResult,
        dispatch_session_id: Optional[str] = None
    ) -> Dict[str, Any]:
        """
        Authorize WRAP generation from an approved BER.
        
        PAC Reference: PAC-BENSON-P57-WRAP-AUTHORIZATION-AND-PDO-FINALIZATION-01
        
        Args:
            ber_approval: Validated BER approval state
            execution_result: Agent execution result
            dispatch_session_id: Session ID from dispatch authorization (P54)
        
        Returns:
            dict with authorization result, WRAP artifact if approved
        
        Invariants:
            - Only BENSON (GID-00) may authorize WRAP generation
            - BER must have human_review_completed=True
            - BER must have no_blocking_violations=True
            - WRAP binds to BER hash for immutability
        """
        timestamp = datetime.now(timezone.utc)
        
        # TELEMETRY: BER Validation Start
        self.telemetry.emit("BER_VALIDATION_START", {
            "ber_id": ber_approval.ber_id,
            "pac_id": ber_approval.pac_id,
            "agent_gid": ber_approval.agent_gid,
            "phase": "WRAP_AUTHORIZATION"
        })
        
        # Check approval conditions
        if not ber_approval.human_review_completed:
            self.telemetry.emit("WRAP_AUTHORIZATION_DENIED", {
                "ber_id": ber_approval.ber_id,
                "reason": "HUMAN_REVIEW_NOT_COMPLETED",
                "phase": "WRAP_AUTHORIZATION"
            })
            return {
                "authorized": False,
                "error_code": "GS_180",
                "message": "BER has not completed human review. WRAP cannot be generated.",
                "ber_id": ber_approval.ber_id,
                "wrap": None,
                "training_signal": self._emit_training_signal(
                    pattern="WRAP_REQUIRES_HUMAN_REVIEW",
                    lesson="WRAP generation requires completed human review of BER.",
                    propagate=True
                )
            }
        
        if not ber_approval.no_blocking_violations:
            self.telemetry.emit("WRAP_AUTHORIZATION_DENIED", {
                "ber_id": ber_approval.ber_id,
                "reason": "BLOCKING_VIOLATIONS_PRESENT",
                "violations": ber_approval.blocking_violations,
                "phase": "WRAP_AUTHORIZATION"
            })
            return {
                "authorized": False,
                "error_code": "GS_181",
                "message": f"BER has blocking violations: {ber_approval.blocking_violations}. WRAP cannot be generated.",
                "ber_id": ber_approval.ber_id,
                "blocking_violations": ber_approval.blocking_violations,
                "wrap": None,
                "training_signal": self._emit_training_signal(
                    pattern="WRAP_BLOCKED_BY_VIOLATIONS",
                    lesson="Blocking violations must be resolved before WRAP generation.",
                    propagate=True
                )
            }
        
        # All checks passed â€” generate WRAP
        pac_number = self._extract_pac_number(ber_approval.pac_id)
        wrap_id = f"WRAP-{ber_approval.agent_name.upper()}-P{pac_number}-{timestamp.strftime('%Y%m%d%H%M%S')}"
        
        # Compute hashes with BER binding
        pac_hash = self._compute_hash(ber_approval.pac_id)
        wrap_content = json.dumps({
            "wrap_id": wrap_id,
            "pac_id": ber_approval.pac_id,
            "ber_id": ber_approval.ber_id,
            "ber_hash": ber_approval.ber_hash,
            "agent_gid": ber_approval.agent_gid,
            "dispatch_session_id": dispatch_session_id,
            "tasks": execution_result.tasks_completed,
            "quality_score": execution_result.quality_score
        }, sort_keys=True)
        wrap_hash = self._compute_hash(wrap_content)
        
        # Generate WRAP artifact
        wrap = WrapArtifact(
            wrap_id=wrap_id,
            pac_id=ber_approval.pac_id,
            agent_gid=ber_approval.agent_gid,
            agent_name=ber_approval.agent_name,
            wrap_hash=wrap_hash,
            pac_hash=pac_hash,
            generated_at=timestamp.isoformat(),
            generated_by=f"{self.AUTHORITY_NAME} ({self.AUTHORITY_GID})",
            status=WrapStatus.WRAP_GENERATED.value,
            quality_score=execution_result.quality_score,
            scope_compliance=execution_result.scope_compliance,
            training_signal=self._emit_training_signal(
                pattern="WRAP_AUTHORIZED_FROM_BER",
                lesson="WRAP generation authorized after BER approval. Execution accepted.",
                propagate=True
            )
        )
        
        # TELEMETRY: WRAP Authorization Granted
        self.telemetry.emit("WRAP_AUTHORIZATION_GRANTED", {
            "ber_id": ber_approval.ber_id,
            "wrap_id": wrap_id,
            "wrap_hash": wrap_hash[:16],
            "ber_hash": ber_approval.ber_hash[:16],
            "phase": "WRAP_AUTHORIZATION"
        })
        
        return {
            "authorized": True,
            "error_code": None,
            "message": "WRAP authorized from approved BER.",
            "ber_id": ber_approval.ber_id,
            "wrap": wrap,
            "ber_hash": ber_approval.ber_hash,
            "wrap_hash": wrap_hash
        }
    
    def finalize_pdo(
        self,
        wrap: WrapArtifact,
        ber_approval: BERApprovalState,
        decision_rationale: str = "BER approved, WRAP authorized",
        dispatch_session_id: Optional[str] = None
    ) -> PDOArtifact:
        """
        Finalize PDO (Proofâ€“Decisionâ€“Outcome) for immutable governance closure.
        
        PAC Reference: PAC-BENSON-P57-WRAP-AUTHORIZATION-AND-PDO-FINALIZATION-01
        
        Args:
            wrap: Authorized WRAP artifact
            ber_approval: Approved BER state
            decision_rationale: Rationale for authorization decision
            dispatch_session_id: Session ID from dispatch authorization (P54)
        
        Returns:
            PDOArtifact with complete proof chain
        
        Invariants:
            - PDO can ONLY be generated by Benson (GID-00)
            - PDO binds BER + WRAP hashes
            - PDO includes doctrine and rules hashes
            - PDO is atomically recorded to ledger
        """
        timestamp = datetime.now(timezone.utc)
        
        # Generate PDO ID
        pac_number = self._extract_pac_number(wrap.pac_id)
        pdo_id = f"PDO-{wrap.agent_name.upper()}-P{pac_number}-{timestamp.strftime('%Y%m%d%H%M%S')}"
        
        # Compute proof hashes
        pac_hash = wrap.pac_hash
        ber_hash = ber_approval.ber_hash
        wrap_hash = wrap.wrap_hash
        
        # Combined proof hash
        proof_content = f"{ber_hash}:{wrap_hash}:{pac_hash}"
        proof_combined_hash = self._compute_hash(proof_content)
        
        # Compute doctrine hash
        doctrine_hash = None
        if DOCTRINE_PATH.exists():
            doctrine_content = DOCTRINE_PATH.read_text()
            doctrine_hash = self._compute_hash(doctrine_content)
        
        # Compute rules hash
        rules_hash = None
        if GOVERNANCE_RULES_PATH.exists():
            rules_content = GOVERNANCE_RULES_PATH.read_text()
            rules_hash = self._compute_hash(rules_content)
        
        # Generate training signal
        training_signal = self._emit_training_signal(
            pattern="PDO_FINALIZED",
            lesson="PDO finalizes execution with immutable proof chain. Decision authority: BENSON (GID-00).",
            propagate=True
        )
        
        pdo = PDOArtifact(
            pdo_id=pdo_id,
            pac_id=wrap.pac_id,
            ber_id=ber_approval.ber_id,
            wrap_id=wrap.wrap_id,
            agent_gid=wrap.agent_gid,
            agent_name=wrap.agent_name,
            
            # Proof
            proof_ber_hash=ber_hash,
            proof_wrap_hash=wrap_hash,
            proof_pac_hash=pac_hash,
            proof_combined_hash=proof_combined_hash,
            
            # Decision
            decision_authority=f"{self.AUTHORITY_NAME} ({self.AUTHORITY_GID})",
            decision_timestamp=timestamp.isoformat(),
            decision_type="AUTHORIZATION_GRANTED",
            decision_rationale=decision_rationale,
            
            # Outcome
            outcome_status="EXECUTION_ACCEPTED",
            outcome_timestamp=timestamp.isoformat(),
            
            # Metadata
            status=PDOStatus.FINALIZED.value,
            doctrine_hash=doctrine_hash,
            rules_hash=rules_hash,
            dispatch_session_id=dispatch_session_id,
            
            # Training
            training_signal=training_signal
        )
        
        # TELEMETRY: PDO Finalized
        self.telemetry.emit("PDO_FINALIZED", {
            "pdo_id": pdo_id,
            "pac_id": wrap.pac_id,
            "ber_id": ber_approval.ber_id,
            "wrap_id": wrap.wrap_id,
            "proof_combined_hash": proof_combined_hash[:16],
            "decision_type": "AUTHORIZATION_GRANTED",
            "outcome_status": "EXECUTION_ACCEPTED",
            "phase": "PDO_FINALIZATION"
        })
        
        return pdo
    
    def commit_wrap_accepted(
        self,
        wrap: WrapArtifact,
        pdo: PDOArtifact,
        ber_approval: BERApprovalState
    ) -> Dict[str, Any]:
        """
        Commit WRAP_ACCEPTED to governance ledger atomically.
        
        PAC Reference: PAC-BENSON-P57-WRAP-AUTHORIZATION-AND-PDO-FINALIZATION-01
        
        Args:
            wrap: Authorized WRAP artifact
            pdo: Finalized PDO artifact
            ber_approval: Approved BER state
        
        Returns:
            dict with ledger commit result
        
        Invariants:
            - Only Benson (GID-00) may emit WRAP_ACCEPTED
            - Ledger write is atomic
            - Any schema mismatch triggers FAIL_CLOSED
        """
        timestamp = datetime.now(timezone.utc)
        
        if not self.ledger:
            return {
                "committed": False,
                "error_code": "GS_182",
                "message": "Ledger not available. WRAP_ACCEPTED cannot be committed.",
                "wrap_id": wrap.wrap_id
            }
        
        try:
            # Record WRAP_ACCEPTED
            entry = self.ledger.record_wrap_accepted(
                artifact_id=wrap.wrap_id,
                agent_gid=wrap.agent_gid,
                agent_name=wrap.agent_name,
                ratified_by=f"{self.AUTHORITY_NAME} ({self.AUTHORITY_GID})",
                notes=f"PAC: {wrap.pac_id}, BER: {ber_approval.ber_id}, PDO: {pdo.pdo_id}, "
                      f"Quality: {wrap.quality_score}, Proof: {pdo.proof_combined_hash[:16]}"
            )
            
            # TELEMETRY: WRAP_ACCEPTED Committed
            self.telemetry.emit("WRAP_ACCEPTED_COMMITTED", {
                "wrap_id": wrap.wrap_id,
                "pdo_id": pdo.pdo_id,
                "ledger_sequence": entry.sequence if hasattr(entry, 'sequence') else None,
                "ledger_entry_hash": entry.entry_hash if hasattr(entry, 'entry_hash') else None,
                "phase": "LEDGER_COMMIT"
            })
            
            return {
                "committed": True,
                "error_code": None,
                "message": "WRAP_ACCEPTED committed to ledger.",
                "wrap_id": wrap.wrap_id,
                "pdo_id": pdo.pdo_id,
                "ledger_entry": entry if hasattr(entry, '__dict__') else str(entry)
            }
            
        except Exception as e:
            self.telemetry.emit("WRAP_ACCEPTED_COMMIT_FAILED", {
                "wrap_id": wrap.wrap_id,
                "error": str(e),
                "phase": "LEDGER_COMMIT"
            })
            return {
                "committed": False,
                "error_code": "GS_183",
                "message": f"Ledger commit failed: {str(e)}",
                "wrap_id": wrap.wrap_id
            }
    
    def emit_execution_governance_success(
        self,
        wrap: WrapArtifact,
        pdo: PDOArtifact
    ) -> Dict[str, Any]:
        """
        Emit TrainingSignal.EXECUTION_GOVERNANCE_SUCCESS.
        
        PAC Reference: PAC-BENSON-P57-WRAP-AUTHORIZATION-AND-PDO-FINALIZATION-01
        
        Args:
            wrap: Authorized WRAP artifact
            pdo: Finalized PDO artifact
        
        Returns:
            Training signal artifact
        """
        training_signal = self._emit_training_signal(
            pattern="EXECUTION_GOVERNANCE_SUCCESS",
            lesson="Complete governance chain executed: PAC â†’ Dispatch â†’ Execution â†’ BER â†’ WRAP â†’ PDO. "
                   "Authority: BENSON (GID-00). All invariants enforced.",
            propagate=True
        )
        
        # Add context
        training_signal["context"] = {
            "wrap_id": wrap.wrap_id,
            "pdo_id": pdo.pdo_id,
            "pac_id": wrap.pac_id,
            "agent_gid": wrap.agent_gid,
            "proof_chain": pdo.proof_combined_hash[:32],
            "decision_authority": pdo.decision_authority,
            "outcome_status": pdo.outcome_status
        }
        
        # TELEMETRY: Training Signal Emitted
        self.telemetry.emit("TRAINING_SIGNAL_EMITTED", {
            "signal_pattern": "EXECUTION_GOVERNANCE_SUCCESS",
            "wrap_id": wrap.wrap_id,
            "pdo_id": pdo.pdo_id,
            "propagate": True,
            "phase": "TRAINING_SIGNAL"
        })
        
        return training_signal
    
    def execute_full_wrap_authorization_and_pdo(
        self,
        pac_id: str,
        agent_gid: str,
        agent_name: str,
        execution_result: ExecutionResult,
        ber_data: Dict[str, Any],
        dispatch_session_id: Optional[str] = None
    ) -> Dict[str, Any]:
        """
        Execute full WRAP authorization and PDO finalization pipeline.
        
        PAC Reference: PAC-BENSON-P57-WRAP-AUTHORIZATION-AND-PDO-FINALIZATION-01
        
        This is the complete pipeline:
        1. Validate BER approval state (T1)
        2. Generate WRAP from BER (T2)
        3. Finalize PDO (T3)
        4. Commit WRAP_ACCEPTED to ledger (T4)
        5. Emit Training Signal (T5)
        
        Args:
            pac_id: PAC identifier
            agent_gid: Agent GID
            agent_name: Agent name
            execution_result: Agent execution result
            ber_data: BER content dictionary
            dispatch_session_id: Session ID from dispatch (P54)
        
        Returns:
            Complete result with WRAP, PDO, ledger entry, training signal
        """
        timestamp = datetime.now(timezone.utc)
        ber_id = ber_data.get("ber_id", f"BER-{pac_id}")
        
        # TELEMETRY: Full Pipeline Start
        self.telemetry.emit("WRAP_PDO_PIPELINE_START", {
            "pac_id": pac_id,
            "ber_id": ber_id,
            "agent_gid": agent_gid,
            "dispatch_session_id": dispatch_session_id,
            "phase": "PIPELINE_START"
        })
        
        # T1: Validate BER approval state
        ber_approval = self.validate_ber_approval(
            ber_id=ber_id,
            pac_id=pac_id,
            agent_gid=agent_gid,
            agent_name=agent_name,
            ber_data=ber_data
        )
        
        # T2: Authorize WRAP from BER
        wrap_result = self.authorize_wrap_from_ber(
            ber_approval=ber_approval,
            execution_result=execution_result,
            dispatch_session_id=dispatch_session_id
        )
        
        if not wrap_result["authorized"]:
            return {
                "success": False,
                "stage": "WRAP_AUTHORIZATION",
                "error_code": wrap_result["error_code"],
                "message": wrap_result["message"],
                "ber_approval": ber_approval,
                "wrap": None,
                "pdo": None,
                "ledger_commit": None,
                "training_signal": wrap_result.get("training_signal")
            }
        
        wrap = wrap_result["wrap"]
        
        # T3: Finalize PDO
        pdo = self.finalize_pdo(
            wrap=wrap,
            ber_approval=ber_approval,
            decision_rationale="BER approved by human review. No blocking violations. WRAP authorized.",
            dispatch_session_id=dispatch_session_id
        )
        
        # T4: Commit WRAP_ACCEPTED to ledger
        ledger_result = self.commit_wrap_accepted(
            wrap=wrap,
            pdo=pdo,
            ber_approval=ber_approval
        )
        
        # T5: Emit Training Signal
        training_signal = self.emit_execution_governance_success(wrap, pdo)
        
        # TELEMETRY: Full Pipeline Complete
        self.telemetry.emit("WRAP_PDO_PIPELINE_COMPLETE", {
            "pac_id": pac_id,
            "ber_id": ber_id,
            "wrap_id": wrap.wrap_id,
            "pdo_id": pdo.pdo_id,
            "ledger_committed": ledger_result["committed"],
            "phase": "PIPELINE_COMPLETE"
        })
        
        return {
            "success": True,
            "stage": "COMPLETE",
            "error_code": None,
            "message": "WRAP authorization and PDO finalization complete.",
            "ber_approval": ber_approval,
            "wrap": wrap,
            "pdo": pdo,
            "ledger_commit": ledger_result,
            "training_signal": training_signal
        }


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# CLI INTERFACE
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

def main():
    """
    Benson Execution Runtime CLI.
    
    Usage:
        python benson_execution.py --pac <PAC_ID> --agent <GID> --result <JSON_FILE>
        python benson_execution.py --validate-agent <GID> <NAME>
        python benson_execution.py --block-test <GID> <NAME>
    """
    parser = argparse.ArgumentParser(
        description="Benson Execution Runtime â€” Authoritative PAC Execution Engine",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  Execute PAC:
    python benson_execution.py --pac PAC-ATLAS-P46-EXAMPLE-01 --agent GID-05 --result result.json
  
  Validate agent activation:
    python benson_execution.py --validate-agent GID-05 ATLAS
  
  Test block enforcement:
    python benson_execution.py --block-test GID-05 ATLAS
        """
    )
    
    parser.add_argument("--pac", type=str, help="PAC ID to execute")
    parser.add_argument("--agent", type=str, help="Agent GID performing execution")
    parser.add_argument("--agent-name", type=str, help="Agent name")
    parser.add_argument("--result", type=str, help="Path to execution result JSON file")
    parser.add_argument("--validate-agent", nargs=2, metavar=("GID", "NAME"), help="Validate agent activation")
    parser.add_argument("--block-test", nargs=2, metavar=("GID", "NAME"), help="Test block enforcement")
    parser.add_argument("--json", action="store_true", help="Output as JSON")
    
    args = parser.parse_args()
    
    engine = BensonExecutionEngine()
    
    if args.validate_agent:
        gid, name = args.validate_agent
        result = engine.validate_agent_activation(gid, name, engine.EXECUTION_LANE)
        if args.json:
            print(json.dumps(result, indent=2))
        else:
            status = "âœ… PASS" if result["valid"] else "âŒ FAIL"
            print(f"{status}: {result['message']}")
        sys.exit(0 if result["valid"] else 1)
    
    elif args.block_test:
        gid, name = args.block_test
        result = engine.block_agent_wrap_emission(gid, name, "TEST_WRAP_EMISSION")
        if args.json:
            print(json.dumps(result, indent=2, default=str))
        else:
            print("=" * 60)
            print("ğŸš« BLOCK ENFORCEMENT TEST")
            print("=" * 60)
            print(f"Block Type: {result['block_type']}")
            print(f"Error Code: {result['error_code']}")
            print(f"Agent: {result['agent_name']} ({result['agent_gid']})")
            print(f"Message: {result['message']}")
            print()
            print("Training Signal:")
            print(f"  Pattern: {result['training_signal']['pattern']}")
            print(f"  Lesson: {result['training_signal']['lesson']}")
        sys.exit(0)
    
    elif args.pac and args.agent and args.result:
        # Load execution result
        try:
            with open(args.result, 'r') as f:
                result_data = json.load(f)
        except FileNotFoundError:
            print(f"âŒ Execution result file not found: {args.result}")
            sys.exit(1)
        except json.JSONDecodeError:
            print(f"âŒ Invalid JSON in execution result file: {args.result}")
            sys.exit(1)
        
        # Create ExecutionResult
        execution_result = ExecutionResult(
            pac_id=args.pac,
            agent_gid=args.agent,
            agent_name=args.agent_name or result_data.get("agent_name", "UNKNOWN"),
            execution_timestamp=result_data.get("timestamp", datetime.now(timezone.utc).isoformat()),
            tasks_completed=result_data.get("tasks_completed", []),
            files_modified=result_data.get("files_modified", []),
            quality_score=result_data.get("quality_score", 0.0),
            scope_compliance=result_data.get("scope_compliance", False),
            execution_time_ms=result_data.get("execution_time_ms", 0)
        )
        
        # Execute PAC
        result = engine.execute_pac(
            pac_id=args.pac,
            agent_gid=args.agent,
            agent_name=execution_result.agent_name,
            execution_result=execution_result
        )
        
        if args.json:
            # Convert dataclasses to dicts for JSON output
            def to_dict(obj):
                if hasattr(obj, '__dict__'):
                    return {k: to_dict(v) for k, v in obj.__dict__.items()}
                elif isinstance(obj, list):
                    return [to_dict(i) for i in obj]
                else:
                    return obj
            print(json.dumps(to_dict(result), indent=2, default=str))
        else:
            print("=" * 60)
            print("ğŸŸ¦ğŸŸ© BENSON EXECUTION RUNTIME â€” RESULT")
            print("=" * 60)
            print(f"PAC: {args.pac}")
            print(f"Agent: {execution_result.agent_name} ({args.agent})")
            print(f"Status: {result['status']}")
            print()
            print("Checkpoints:")
            for cp in result.get("checkpoints", []):
                status_icon = "âœ…" if cp.status == "PASS" else "âŒ"
                print(f"  {status_icon} {cp.checkpoint_name}: {cp.status}")
            print()
            if result.get("wrap"):
                print("WRAP Generated:")
                print(f"  ID: {result['wrap'].wrap_id}")
                print(f"  Hash: {result['wrap'].wrap_hash[:16]}...")
                print(f"  Authority: {result['wrap'].generated_by}")
        
        sys.exit(0 if result["status"] == ExecutionStatus.COMPLETED.value else 1)
    
    else:
        parser.print_help()
        sys.exit(0)


if __name__ == "__main__":
    main()
