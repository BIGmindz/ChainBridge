"""
Multi-Agent Orchestration Execution Module

Authority: PAC-BENSON-P66-MULTI-AGENT-ORCHESTRATION-GOVERNED-EXECUTION-MODEL-01
Doctrine Reference: GOVERNANCE_DOCTRINE_V1.3

This module extends the Benson Execution Engine to support governed
multi-agent orchestration. It provides:

1. MAEG-based orchestration dispatch
2. Per-agent Sub-PAC generation and dispatch
3. Per-agent BER generation
4. PDO aggregation into PDO-ORCH
5. Single WRAP emission for orchestration

INVARIANTS:
  - NO_AGENT_EXECUTES_WITHOUT_DISPATCH
  - NO_PARALLEL_EXECUTION_WITHOUT_SUB_PAC
  - EACH_AGENT_EMITS_INDIVIDUAL_BER
  - NO_SHARED_STATE_MUTATION
  - ORCHESTRATOR_HAS_ZERO_BUSINESS_LOGIC

ERROR CODES:
  GS_200: SUB_PAC_LANE_VIOLATION
  GS_201: SUB_PAC_SCOPE_EXPANSION
  GS_202: MAEG_CYCLE_DETECTED
  GS_203: DISPATCH_DEPENDENCY_UNMET
  GS_204: BER_DEPENDENCY_UNMET
  GS_205: PDO_ORCH_INCOMPLETE
  GS_206: WRAP_PARTIAL_EXECUTION
  GS_207: AGENT_SIDE_CHANNEL
"""

from __future__ import annotations

import hashlib
import json
import uuid
from dataclasses import dataclass, field
from datetime import datetime, timezone
from enum import Enum
from pathlib import Path
from typing import Any, Callable, Optional

# Import schema definitions
from schemas.orchestration_graph import (
    MultiAgentExecutionGraph,
    MAEGNode,
    MAEGEdge,
    MAEGSyncPoint,
    MAEGStatus,
    NodeType,
    EdgeType,
    create_maeg,
    build_linear_maeg,
    build_parallel_maeg,
    build_fanout_fanin_maeg,
)
from schemas.sub_pac import (
    SubPAC,
    SubPACStatus,
    SubPACOutput,
    AgentAssignment,
    SubPACDependencies,
    SubPACScope,
    create_sub_pac,
)


# ════════════════════════════════════════════════════════════════════════════
# ORCHESTRATION STATUS
# ════════════════════════════════════════════════════════════════════════════

class OrchestrationStatus(str, Enum):
    """Status of multi-agent orchestration execution."""
    
    INITIALIZED = "INITIALIZED"
    MAEG_CREATED = "MAEG_CREATED"
    SUB_PACS_GENERATED = "SUB_PACS_GENERATED"
    DISPATCHING = "DISPATCHING"
    EXECUTING = "EXECUTING"
    BERS_PENDING = "BERS_PENDING"
    PDOS_PENDING = "PDOS_PENDING"
    AGGREGATING = "AGGREGATING"
    WRAP_PENDING = "WRAP_PENDING"
    COMPLETE = "COMPLETE"
    FAILED = "FAILED"


# ════════════════════════════════════════════════════════════════════════════
# PER-AGENT BER
# ════════════════════════════════════════════════════════════════════════════

@dataclass
class AgentBER:
    """
    Per-agent Benson Execution Report for multi-agent orchestration.
    
    Each agent in the orchestration produces its own BER, which is:
    - Generated by Benson (not the agent)
    - Independently reviewed
    - Required for downstream dispatch
    - Recorded to the ledger
    """
    
    ber_id: str  # e.g., "BER-A1-BENSON-P66"
    sub_pac_id: str
    parent_pac_id: str
    maeg_node_id: str
    
    # Agent info
    agent_gid: str
    agent_name: str
    execution_lane: str
    
    # Execution result
    execution_result_id: str
    execution_result_hash: str
    tasks_completed: int
    quality_score: float
    
    # BER evaluation
    human_review_required: bool
    human_review_completed: bool = False
    human_reviewer: Optional[str] = None
    human_review_timestamp: Optional[str] = None
    
    # Violations
    blocking_violations: list[str] = field(default_factory=list)
    warnings: list[str] = field(default_factory=list)
    
    # Status
    status: str = "PENDING"  # PENDING | PASS | FAIL | BLOCKED
    
    # Hash
    ber_hash: Optional[str] = None
    created_at: str = field(default_factory=lambda: datetime.now(timezone.utc).isoformat())
    
    def __post_init__(self):
        """Compute BER hash after initialization."""
        self.ber_hash = self._compute_hash()
    
    def _compute_hash(self) -> str:
        """Compute the BER hash for integrity verification."""
        content = {
            "ber_id": self.ber_id,
            "sub_pac_id": self.sub_pac_id,
            "execution_result_hash": self.execution_result_hash,
            "agent_gid": self.agent_gid,
            "created_at": self.created_at,
        }
        canonical = json.dumps(content, sort_keys=True)
        return hashlib.sha256(canonical.encode()).hexdigest()
    
    def pass_review(self, reviewer: Optional[str] = None) -> None:
        """Mark the BER as passed."""
        if self.human_review_required and not reviewer:
            raise ValueError("Human reviewer required for this BER")
        self.status = "PASS"
        if reviewer:
            self.human_review_completed = True
            self.human_reviewer = reviewer
            self.human_review_timestamp = datetime.now(timezone.utc).isoformat()
    
    def fail_review(self, reason: str, reviewer: Optional[str] = None) -> None:
        """Mark the BER as failed."""
        self.status = "FAIL"
        self.blocking_violations.append(reason)
        if reviewer:
            self.human_review_completed = True
            self.human_reviewer = reviewer
            self.human_review_timestamp = datetime.now(timezone.utc).isoformat()
    
    def is_passed(self) -> bool:
        """Check if the BER has passed."""
        return self.status == "PASS"
    
    def to_dict(self) -> dict[str, Any]:
        """Convert to dictionary representation."""
        return {
            "ber_id": self.ber_id,
            "sub_pac_id": self.sub_pac_id,
            "parent_pac_id": self.parent_pac_id,
            "maeg_node_id": self.maeg_node_id,
            "agent_gid": self.agent_gid,
            "agent_name": self.agent_name,
            "execution_lane": self.execution_lane,
            "execution_result_id": self.execution_result_id,
            "execution_result_hash": self.execution_result_hash,
            "tasks_completed": self.tasks_completed,
            "quality_score": self.quality_score,
            "human_review_required": self.human_review_required,
            "human_review_completed": self.human_review_completed,
            "human_reviewer": self.human_reviewer,
            "human_review_timestamp": self.human_review_timestamp,
            "blocking_violations": self.blocking_violations,
            "warnings": self.warnings,
            "status": self.status,
            "ber_hash": self.ber_hash,
            "created_at": self.created_at,
        }


# ════════════════════════════════════════════════════════════════════════════
# PER-AGENT PDO
# ════════════════════════════════════════════════════════════════════════════

@dataclass
class AgentPDO:
    """
    Per-agent Proof-Decision-Outcome for multi-agent orchestration.
    
    Each agent produces its own PDO, which feeds into PDO-ORCH aggregation.
    """
    
    pdo_id: str  # e.g., "PDO-A1-BENSON-P66"
    sub_pac_id: str
    parent_pac_id: str
    maeg_node_id: str
    ber_id: str
    
    # Agent info
    agent_gid: str
    agent_name: str
    
    # Proof
    proof_ber_hash: str
    proof_execution_result_hash: str
    proof_sub_pac_hash: str
    proof_combined_hash: str  # SHA256(ber + result + sub_pac)
    
    # Decision
    decision_authority: str = "BENSON (GID-00)"
    decision_timestamp: str = field(default_factory=lambda: datetime.now(timezone.utc).isoformat())
    decision_type: str = "AGENT_EXECUTION_APPROVED"  # or AGENT_EXECUTION_REJECTED
    
    # Outcome
    outcome_status: str = "FINALIZED"  # FINALIZED | REJECTED
    
    # Hash
    pdo_hash: Optional[str] = None
    
    def __post_init__(self):
        """Compute PDO hash after initialization."""
        self.pdo_hash = self._compute_hash()
    
    def _compute_hash(self) -> str:
        """Compute the PDO hash for integrity verification."""
        content = {
            "pdo_id": self.pdo_id,
            "sub_pac_id": self.sub_pac_id,
            "ber_id": self.ber_id,
            "proof_combined_hash": self.proof_combined_hash,
            "decision_timestamp": self.decision_timestamp,
        }
        canonical = json.dumps(content, sort_keys=True)
        return hashlib.sha256(canonical.encode()).hexdigest()
    
    def to_dict(self) -> dict[str, Any]:
        """Convert to dictionary representation."""
        return {
            "pdo_id": self.pdo_id,
            "sub_pac_id": self.sub_pac_id,
            "parent_pac_id": self.parent_pac_id,
            "maeg_node_id": self.maeg_node_id,
            "ber_id": self.ber_id,
            "agent_gid": self.agent_gid,
            "agent_name": self.agent_name,
            "proof_ber_hash": self.proof_ber_hash,
            "proof_execution_result_hash": self.proof_execution_result_hash,
            "proof_sub_pac_hash": self.proof_sub_pac_hash,
            "proof_combined_hash": self.proof_combined_hash,
            "decision_authority": self.decision_authority,
            "decision_timestamp": self.decision_timestamp,
            "decision_type": self.decision_type,
            "outcome_status": self.outcome_status,
            "pdo_hash": self.pdo_hash,
        }


# ════════════════════════════════════════════════════════════════════════════
# PDO-ORCH (ORCHESTRATION PDO)
# ════════════════════════════════════════════════════════════════════════════

@dataclass
class PDOOrchestration:
    """
    Orchestration PDO that aggregates all agent PDOs.
    
    The PDO-ORCH is the final proof artifact for multi-agent execution.
    It aggregates all child PDOs via merkle root and enables single WRAP.
    """
    
    pdo_orch_id: str  # e.g., "PDO-ORCH-BENSON-P66"
    parent_pac_id: str
    maeg_id: str
    
    # Child PDOs
    child_pdos: list[AgentPDO] = field(default_factory=list)
    child_pdo_hashes: list[str] = field(default_factory=list)
    
    # Merkle aggregation
    merkle_root: Optional[str] = None
    
    # Decision
    decision_authority: str = "BENSON (GID-00)"
    decision_timestamp: str = field(default_factory=lambda: datetime.now(timezone.utc).isoformat())
    aggregation_type: str = "MERKLE_AGGREGATION"
    
    # Status
    all_agents_pass: bool = False
    ready_for_wrap: bool = False
    
    # Hash
    pdo_orch_hash: Optional[str] = None
    
    def add_child_pdo(self, pdo: AgentPDO) -> None:
        """Add a child PDO to the aggregation."""
        self.child_pdos.append(pdo)
        self.child_pdo_hashes.append(pdo.pdo_hash)
    
    def finalize(self) -> None:
        """
        Finalize the PDO-ORCH by computing merkle root.
        
        Raises GS_205 if child PDOs are incomplete.
        """
        if not self.child_pdos:
            raise ValueError("GS_205: PDO_ORCH_INCOMPLETE - No child PDOs to aggregate")
        
        # Check all child PDOs are finalized
        for pdo in self.child_pdos:
            if pdo.outcome_status != "FINALIZED":
                raise ValueError(
                    f"GS_205: PDO_ORCH_INCOMPLETE - Child PDO {pdo.pdo_id} "
                    f"has status {pdo.outcome_status}"
                )
        
        # Compute merkle root
        self.merkle_root = self._compute_merkle_root()
        self.all_agents_pass = True
        self.ready_for_wrap = True
        self.pdo_orch_hash = self._compute_hash()
    
    def _compute_merkle_root(self) -> str:
        """Compute merkle root of child PDO hashes."""
        if not self.child_pdo_hashes:
            return hashlib.sha256(b"EMPTY").hexdigest()
        
        # Simple merkle: hash all hashes together (for demo; real impl would be tree)
        combined = "|".join(sorted(self.child_pdo_hashes))
        return hashlib.sha256(combined.encode()).hexdigest()
    
    def _compute_hash(self) -> str:
        """Compute the PDO-ORCH hash."""
        content = {
            "pdo_orch_id": self.pdo_orch_id,
            "parent_pac_id": self.parent_pac_id,
            "maeg_id": self.maeg_id,
            "merkle_root": self.merkle_root,
            "decision_timestamp": self.decision_timestamp,
        }
        canonical = json.dumps(content, sort_keys=True)
        return hashlib.sha256(canonical.encode()).hexdigest()
    
    def to_dict(self) -> dict[str, Any]:
        """Convert to dictionary representation."""
        return {
            "pdo_orch_id": self.pdo_orch_id,
            "parent_pac_id": self.parent_pac_id,
            "maeg_id": self.maeg_id,
            "child_pdos": [p.to_dict() for p in self.child_pdos],
            "child_pdo_hashes": self.child_pdo_hashes,
            "merkle_root": self.merkle_root,
            "decision_authority": self.decision_authority,
            "decision_timestamp": self.decision_timestamp,
            "aggregation_type": self.aggregation_type,
            "all_agents_pass": self.all_agents_pass,
            "ready_for_wrap": self.ready_for_wrap,
            "pdo_orch_hash": self.pdo_orch_hash,
        }


# ════════════════════════════════════════════════════════════════════════════
# ORCHESTRATION WRAP
# ════════════════════════════════════════════════════════════════════════════

@dataclass
class OrchestrationWRAP:
    """
    Single WRAP for multi-agent orchestration.
    
    Regardless of the number of agents involved, only one WRAP is emitted.
    This provides atomic settlement for the entire orchestration.
    """
    
    wrap_id: str  # e.g., "WRAP-ORCH-BENSON-P66"
    parent_pac_id: str
    maeg_id: str
    pdo_orch_id: str
    
    # Orchestration info
    orchestration_type: str = "MULTI_AGENT"
    agent_count: int = 0
    
    # Sub-PAC summary
    sub_pacs: list[dict] = field(default_factory=list)  # [{sub_pac_id, agent_gid, ber_id, pdo_id, status}]
    
    # Aggregation
    pdo_orch_hash: str = ""
    merkle_root: str = ""
    
    # Settlement
    status: str = "WRAP_ACCEPTED"
    authority: str = "BENSON (GID-00)"
    timestamp: str = field(default_factory=lambda: datetime.now(timezone.utc).isoformat())
    
    # Hash
    wrap_hash: Optional[str] = None
    
    def __post_init__(self):
        """Compute WRAP hash after initialization."""
        if self.pdo_orch_hash:  # Only compute if we have the required data
            self.wrap_hash = self._compute_hash()
    
    def _compute_hash(self) -> str:
        """Compute the WRAP hash."""
        content = {
            "wrap_id": self.wrap_id,
            "parent_pac_id": self.parent_pac_id,
            "pdo_orch_id": self.pdo_orch_id,
            "merkle_root": self.merkle_root,
            "timestamp": self.timestamp,
        }
        canonical = json.dumps(content, sort_keys=True)
        return hashlib.sha256(canonical.encode()).hexdigest()
    
    def to_dict(self) -> dict[str, Any]:
        """Convert to dictionary representation."""
        return {
            "wrap_id": self.wrap_id,
            "parent_pac_id": self.parent_pac_id,
            "maeg_id": self.maeg_id,
            "pdo_orch_id": self.pdo_orch_id,
            "orchestration_type": self.orchestration_type,
            "agent_count": self.agent_count,
            "sub_pacs": self.sub_pacs,
            "pdo_orch_hash": self.pdo_orch_hash,
            "merkle_root": self.merkle_root,
            "status": self.status,
            "authority": self.authority,
            "timestamp": self.timestamp,
            "wrap_hash": self.wrap_hash,
        }


# ════════════════════════════════════════════════════════════════════════════
# MULTI-AGENT ORCHESTRATOR
# ════════════════════════════════════════════════════════════════════════════

class MultiAgentOrchestrator:
    """
    Governed Multi-Agent Orchestration Engine.
    
    This class coordinates the execution of multiple agents while maintaining
    full governance discipline. It ensures:
    
    1. Every agent receives a Sub-PAC
    2. Every agent receives explicit dispatch authorization
    3. Every agent produces an independent BER
    4. Every agent produces an independent PDO
    5. All PDOs aggregate into a single PDO-ORCH
    6. A single WRAP is emitted for the entire orchestration
    
    Authority: BENSON (GID-00)
    Mode: FAIL_CLOSED
    
    INVARIANTS:
      - NO_AGENT_EXECUTES_WITHOUT_DISPATCH
      - NO_PARALLEL_EXECUTION_WITHOUT_SUB_PAC
      - EACH_AGENT_EMITS_INDIVIDUAL_BER
      - NO_SHARED_STATE_MUTATION
      - ORCHESTRATOR_HAS_ZERO_BUSINESS_LOGIC
    """
    
    AUTHORITY_GID = "GID-00"
    AUTHORITY_NAME = "BENSON"
    VERSION = "1.0.0"
    
    def __init__(self, benson_engine: Any = None):
        """
        Initialize the Multi-Agent Orchestrator.
        
        Args:
            benson_engine: Optional BensonExecutionEngine instance for dispatch.
        """
        self.benson_engine = benson_engine
        
        # State tracking
        self.maeg: Optional[MultiAgentExecutionGraph] = None
        self.sub_pacs: dict[str, SubPAC] = {}  # node_id -> SubPAC
        self.bers: dict[str, AgentBER] = {}  # node_id -> AgentBER
        self.pdos: dict[str, AgentPDO] = {}  # node_id -> AgentPDO
        self.pdo_orch: Optional[PDOOrchestration] = None
        self.wrap: Optional[OrchestrationWRAP] = None
        
        # Dispatch tokens (node_id -> dispatch_session_id)
        self.dispatch_tokens: dict[str, str] = {}
        
        # Status
        self.status = OrchestrationStatus.INITIALIZED
        self.parent_pac_id: Optional[str] = None
        
        # Event log
        self.event_log: list[dict] = []
    
    def _log_event(self, event_type: str, data: dict) -> None:
        """Log an orchestration event."""
        self.event_log.append({
            "event_type": event_type,
            "timestamp": datetime.now(timezone.utc).isoformat(),
            "authority": f"{self.AUTHORITY_NAME} ({self.AUTHORITY_GID})",
            "data": data,
        })
    
    def _generate_session_id(self) -> str:
        """Generate a unique session ID."""
        return f"ORCH-SESSION-{uuid.uuid4().hex[:12].upper()}"
    
    # ────────────────────────────────────────────────────────────────────────
    # PHASE 1: MAEG Creation
    # ────────────────────────────────────────────────────────────────────────
    
    def create_maeg(self, parent_pac_id: str) -> MultiAgentExecutionGraph:
        """
        Create a new Multi-Agent Execution Graph for the orchestration.
        
        Args:
            parent_pac_id: The parent PAC ID for this orchestration.
        
        Returns:
            A new MultiAgentExecutionGraph instance.
        """
        self.parent_pac_id = parent_pac_id
        self.maeg = create_maeg(parent_pac_id)
        self.status = OrchestrationStatus.MAEG_CREATED
        
        self._log_event("MAEG_CREATED", {
            "maeg_id": self.maeg.maeg_id,
            "parent_pac_id": parent_pac_id,
        })
        
        return self.maeg
    
    def set_maeg(self, maeg: MultiAgentExecutionGraph) -> None:
        """
        Set an externally-created MAEG for this orchestration.
        
        Args:
            maeg: A MultiAgentExecutionGraph instance.
        """
        self.maeg = maeg
        self.parent_pac_id = maeg.parent_pac_id
        self.status = OrchestrationStatus.MAEG_CREATED
        
        self._log_event("MAEG_SET", {
            "maeg_id": maeg.maeg_id,
            "parent_pac_id": maeg.parent_pac_id,
            "node_count": len(maeg.nodes),
        })
    
    # ────────────────────────────────────────────────────────────────────────
    # PHASE 2: Sub-PAC Generation
    # ────────────────────────────────────────────────────────────────────────
    
    def generate_sub_pacs(self) -> list[SubPAC]:
        """
        Generate Sub-PACs for all agent nodes in the MAEG.
        
        Returns:
            List of generated SubPACs.
        
        Raises:
            ValueError: If MAEG has not been created.
        """
        if not self.maeg:
            raise ValueError("MAEG must be created before generating Sub-PACs")
        
        sub_pacs = self.maeg.generate_sub_pacs()
        
        for sub_pac in sub_pacs:
            self.sub_pacs[sub_pac.maeg_node_id] = sub_pac
        
        self.status = OrchestrationStatus.SUB_PACS_GENERATED
        
        self._log_event("SUB_PACS_GENERATED", {
            "count": len(sub_pacs),
            "sub_pac_ids": [sp.sub_pac_id for sp in sub_pacs],
        })
        
        return sub_pacs
    
    # ────────────────────────────────────────────────────────────────────────
    # PHASE 3: Dispatch Authorization
    # ────────────────────────────────────────────────────────────────────────
    
    def dispatch_node(self, node_id: str) -> str:
        """
        Dispatch a single agent node.
        
        Args:
            node_id: The MAEG node ID to dispatch.
        
        Returns:
            The dispatch session ID.
        
        Raises:
            ValueError: If node cannot be dispatched.
        """
        if not self.maeg:
            raise ValueError("MAEG must be created before dispatch")
        
        if node_id not in self.maeg.nodes:
            raise ValueError(f"Node {node_id} not found in MAEG")
        
        node = self.maeg.nodes[node_id]
        sub_pac = self.sub_pacs.get(node_id)
        
        if not sub_pac:
            raise ValueError(f"GS_203: DISPATCH_DEPENDENCY_UNMET - No Sub-PAC for node {node_id}")
        
        # Check dependencies
        dispatchable = self.maeg.get_dispatchable_nodes()
        if node not in dispatchable:
            raise ValueError(
                f"GS_203: DISPATCH_DEPENDENCY_UNMET - Node {node_id} has unmet dependencies"
            )
        
        # Generate dispatch token
        dispatch_session_id = self._generate_session_id()
        self.dispatch_tokens[node_id] = dispatch_session_id
        
        # Update Sub-PAC state
        sub_pac.dispatch(dispatch_session_id)
        
        # Update MAEG state
        self.maeg.mark_node_dispatched(node_id)
        
        if self.status == OrchestrationStatus.SUB_PACS_GENERATED:
            self.status = OrchestrationStatus.DISPATCHING
        
        self._log_event("NODE_DISPATCHED", {
            "node_id": node_id,
            "agent_gid": node.agent_gid,
            "agent_name": node.agent_name,
            "sub_pac_id": sub_pac.sub_pac_id,
            "dispatch_session_id": dispatch_session_id,
        })
        
        return dispatch_session_id
    
    def dispatch_all_root_nodes(self) -> list[str]:
        """
        Dispatch all root nodes (nodes with no dependencies).
        
        Returns:
            List of dispatch session IDs.
        """
        root_nodes = self.maeg.get_root_nodes()
        session_ids = []
        
        for node in root_nodes:
            session_id = self.dispatch_node(node.node_id)
            session_ids.append(session_id)
        
        return session_ids
    
    def dispatch_ready_nodes(self) -> list[str]:
        """
        Dispatch all nodes that are ready for dispatch.
        
        Returns:
            List of dispatch session IDs.
        """
        dispatchable = self.maeg.get_dispatchable_nodes()
        session_ids = []
        
        for node in dispatchable:
            if node.node_id not in self.dispatch_tokens:
                session_id = self.dispatch_node(node.node_id)
                session_ids.append(session_id)
        
        return session_ids
    
    # ────────────────────────────────────────────────────────────────────────
    # PHASE 4: Agent Execution Recording
    # ────────────────────────────────────────────────────────────────────────
    
    def record_execution_result(
        self,
        node_id: str,
        execution_result_id: str,
        execution_result_hash: str,
        tasks_completed: int = 0,
        quality_score: float = 0.0,
    ) -> SubPAC:
        """
        Record an agent's execution result.
        
        This transitions the Sub-PAC from EXECUTING to BER_PENDING.
        
        Args:
            node_id: The MAEG node ID.
            execution_result_id: ID of the execution result.
            execution_result_hash: Hash of the execution result.
            tasks_completed: Number of tasks completed.
            quality_score: Quality score (0.0 to 1.0).
        
        Returns:
            The updated SubPAC.
        """
        sub_pac = self.sub_pacs.get(node_id)
        if not sub_pac:
            raise ValueError(f"No Sub-PAC found for node {node_id}")
        
        # Transition to EXECUTING if not already
        if sub_pac.status == SubPACStatus.DISPATCHED:
            sub_pac.begin_execution()
        
        # Record result and transition to BER_PENDING
        sub_pac.await_ber(execution_result_id, execution_result_hash)
        
        if self.status == OrchestrationStatus.DISPATCHING:
            self.status = OrchestrationStatus.EXECUTING
        
        self._log_event("EXECUTION_RESULT_RECORDED", {
            "node_id": node_id,
            "sub_pac_id": sub_pac.sub_pac_id,
            "execution_result_id": execution_result_id,
            "tasks_completed": tasks_completed,
            "quality_score": quality_score,
        })
        
        return sub_pac
    
    # ────────────────────────────────────────────────────────────────────────
    # PHASE 5: Per-Agent BER Generation
    # ────────────────────────────────────────────────────────────────────────
    
    def generate_agent_ber(
        self,
        node_id: str,
        tasks_completed: int = 0,
        quality_score: float = 0.0,
        human_review_required: bool = True,
        blocking_violations: list[str] | None = None,
        warnings: list[str] | None = None,
    ) -> AgentBER:
        """
        Generate a BER for an agent node.
        
        This is called by Benson (not the agent) after execution completes.
        
        Args:
            node_id: The MAEG node ID.
            tasks_completed: Number of tasks completed.
            quality_score: Quality score (0.0 to 1.0).
            human_review_required: Whether human review is required.
            blocking_violations: List of blocking violation codes.
            warnings: List of warning codes.
        
        Returns:
            The generated AgentBER.
        """
        sub_pac = self.sub_pacs.get(node_id)
        if not sub_pac:
            raise ValueError(f"No Sub-PAC found for node {node_id}")
        
        if sub_pac.status != SubPACStatus.BER_PENDING:
            raise ValueError(
                f"Sub-PAC {sub_pac.sub_pac_id} is not in BER_PENDING status. "
                f"Current status: {sub_pac.status}"
            )
        
        node = self.maeg.nodes[node_id]
        
        # Generate BER ID
        ber_id = f"BER-{node_id}-{self.parent_pac_id.replace('PAC-', '').split('-')[0]}-{self.parent_pac_id.split('-')[2] if len(self.parent_pac_id.split('-')) > 2 else 'XX'}"
        
        ber = AgentBER(
            ber_id=ber_id,
            sub_pac_id=sub_pac.sub_pac_id,
            parent_pac_id=self.parent_pac_id,
            maeg_node_id=node_id,
            agent_gid=node.agent_gid,
            agent_name=node.agent_name,
            execution_lane=node.execution_lane,
            execution_result_id=sub_pac.outputs.execution_result_id,
            execution_result_hash=sub_pac.outputs.execution_result_hash,
            tasks_completed=tasks_completed,
            quality_score=quality_score,
            human_review_required=human_review_required,
            blocking_violations=blocking_violations or [],
            warnings=warnings or [],
        )
        
        self.bers[node_id] = ber
        
        self._log_event("BER_GENERATED", {
            "node_id": node_id,
            "ber_id": ber_id,
            "sub_pac_id": sub_pac.sub_pac_id,
            "human_review_required": human_review_required,
        })
        
        return ber
    
    def approve_agent_ber(
        self,
        node_id: str,
        reviewer: Optional[str] = None,
    ) -> AgentBER:
        """
        Approve an agent's BER (mark as PASS).
        
        Args:
            node_id: The MAEG node ID.
            reviewer: Name of the human reviewer (if required).
        
        Returns:
            The updated AgentBER.
        """
        ber = self.bers.get(node_id)
        if not ber:
            raise ValueError(f"No BER found for node {node_id}")
        
        ber.pass_review(reviewer)
        
        # Update Sub-PAC
        sub_pac = self.sub_pacs[node_id]
        sub_pac.set_ber(ber.ber_id, ber.ber_hash)
        
        self._log_event("BER_APPROVED", {
            "node_id": node_id,
            "ber_id": ber.ber_id,
            "reviewer": reviewer,
        })
        
        return ber
    
    def reject_agent_ber(
        self,
        node_id: str,
        reason: str,
        reviewer: Optional[str] = None,
    ) -> AgentBER:
        """
        Reject an agent's BER (mark as FAIL).
        
        This cascades failure to all dependent nodes.
        
        Args:
            node_id: The MAEG node ID.
            reason: Reason for rejection.
            reviewer: Name of the human reviewer.
        
        Returns:
            The updated AgentBER.
        """
        ber = self.bers.get(node_id)
        if not ber:
            raise ValueError(f"No BER found for node {node_id}")
        
        ber.fail_review(reason, reviewer)
        
        # Update Sub-PAC
        sub_pac = self.sub_pacs[node_id]
        sub_pac.fail(f"BER rejected: {reason}")
        
        # Cascade failure in MAEG
        self.maeg.mark_node_failed(node_id)
        
        self.status = OrchestrationStatus.FAILED
        
        self._log_event("BER_REJECTED", {
            "node_id": node_id,
            "ber_id": ber.ber_id,
            "reason": reason,
            "reviewer": reviewer,
        })
        
        return ber
    
    # ────────────────────────────────────────────────────────────────────────
    # PHASE 6: Per-Agent PDO Generation
    # ────────────────────────────────────────────────────────────────────────
    
    def generate_agent_pdo(self, node_id: str) -> AgentPDO:
        """
        Generate a PDO for an agent node.
        
        Requires BER to be approved first.
        
        Args:
            node_id: The MAEG node ID.
        
        Returns:
            The generated AgentPDO.
        """
        sub_pac = self.sub_pacs.get(node_id)
        ber = self.bers.get(node_id)
        
        if not sub_pac:
            raise ValueError(f"No Sub-PAC found for node {node_id}")
        if not ber:
            raise ValueError(f"GS_204: BER_DEPENDENCY_UNMET - No BER for node {node_id}")
        if not ber.is_passed():
            raise ValueError(f"GS_204: BER_DEPENDENCY_UNMET - BER for node {node_id} has not passed")
        
        node = self.maeg.nodes[node_id]
        
        # Compute combined proof hash
        proof_combined = hashlib.sha256(
            f"{ber.ber_hash}|{sub_pac.outputs.execution_result_hash}|{sub_pac.sub_pac_hash}".encode()
        ).hexdigest()
        
        # Generate PDO ID
        pdo_id = f"PDO-{node_id}-{self.parent_pac_id.replace('PAC-', '').split('-')[0]}-{self.parent_pac_id.split('-')[2] if len(self.parent_pac_id.split('-')) > 2 else 'XX'}"
        
        pdo = AgentPDO(
            pdo_id=pdo_id,
            sub_pac_id=sub_pac.sub_pac_id,
            parent_pac_id=self.parent_pac_id,
            maeg_node_id=node_id,
            ber_id=ber.ber_id,
            agent_gid=node.agent_gid,
            agent_name=node.agent_name,
            proof_ber_hash=ber.ber_hash,
            proof_execution_result_hash=sub_pac.outputs.execution_result_hash,
            proof_sub_pac_hash=sub_pac.sub_pac_hash,
            proof_combined_hash=proof_combined,
        )
        
        self.pdos[node_id] = pdo
        
        # Update Sub-PAC
        sub_pac.set_pdo(pdo.pdo_id, pdo.pdo_hash)
        
        # Update MAEG
        self.maeg.mark_node_completed(node_id)
        
        # Check if we can dispatch more nodes
        self.dispatch_ready_nodes()
        
        self._log_event("PDO_GENERATED", {
            "node_id": node_id,
            "pdo_id": pdo_id,
            "sub_pac_id": sub_pac.sub_pac_id,
            "ber_id": ber.ber_id,
        })
        
        return pdo
    
    # ────────────────────────────────────────────────────────────────────────
    # PHASE 7: PDO-ORCH Aggregation
    # ────────────────────────────────────────────────────────────────────────
    
    def aggregate_pdos(self) -> PDOOrchestration:
        """
        Aggregate all agent PDOs into PDO-ORCH.
        
        Requires all agent nodes to have completed with PDOs.
        
        Returns:
            The PDOOrchestration artifact.
        
        Raises:
            ValueError: If not all agents have completed.
        """
        # Check all agent nodes have completed
        agent_nodes = [n for n in self.maeg.nodes.values() if n.is_agent_node()]
        
        for node in agent_nodes:
            if node.node_id not in self.pdos:
                raise ValueError(
                    f"GS_205: PDO_ORCH_INCOMPLETE - Missing PDO for node {node.node_id}"
                )
        
        # Create PDO-ORCH
        pdo_orch_id = f"PDO-ORCH-{self.parent_pac_id.replace('PAC-', '').split('-')[0]}-{self.parent_pac_id.split('-')[2] if len(self.parent_pac_id.split('-')) > 2 else 'XX'}"
        
        self.pdo_orch = PDOOrchestration(
            pdo_orch_id=pdo_orch_id,
            parent_pac_id=self.parent_pac_id,
            maeg_id=self.maeg.maeg_id,
        )
        
        # Add all child PDOs
        for node_id in sorted(self.pdos.keys()):
            self.pdo_orch.add_child_pdo(self.pdos[node_id])
        
        # Finalize (computes merkle root)
        self.pdo_orch.finalize()
        
        # Update MAEG
        self.maeg.finalize(pdo_orch_id, self.pdo_orch.merkle_root)
        
        self.status = OrchestrationStatus.AGGREGATING
        
        self._log_event("PDO_ORCH_AGGREGATED", {
            "pdo_orch_id": pdo_orch_id,
            "child_count": len(self.pdo_orch.child_pdos),
            "merkle_root": self.pdo_orch.merkle_root,
        })
        
        return self.pdo_orch
    
    # ────────────────────────────────────────────────────────────────────────
    # PHASE 8: Single WRAP Emission
    # ────────────────────────────────────────────────────────────────────────
    
    def emit_wrap(self) -> OrchestrationWRAP:
        """
        Emit the single WRAP for the entire orchestration.
        
        Requires PDO-ORCH to be finalized.
        
        Returns:
            The OrchestrationWRAP artifact.
        
        Raises:
            ValueError: If orchestration is not ready for WRAP.
        """
        if not self.pdo_orch:
            raise ValueError("GS_206: WRAP_PARTIAL_EXECUTION - PDO-ORCH not yet aggregated")
        
        if not self.pdo_orch.ready_for_wrap:
            raise ValueError("GS_206: WRAP_PARTIAL_EXECUTION - PDO-ORCH not ready for WRAP")
        
        # Build sub-PAC summary
        sub_pac_summary = []
        for node_id, sub_pac in self.sub_pacs.items():
            ber = self.bers.get(node_id)
            pdo = self.pdos.get(node_id)
            sub_pac_summary.append({
                "sub_pac_id": sub_pac.sub_pac_id,
                "agent_gid": sub_pac.agent_assignment.agent_gid,
                "ber_id": ber.ber_id if ber else None,
                "pdo_id": pdo.pdo_id if pdo else None,
                "status": sub_pac.status.value,
            })
        
        # Generate WRAP ID
        wrap_id = f"WRAP-ORCH-{self.parent_pac_id.replace('PAC-', '').split('-')[0]}-{self.parent_pac_id.split('-')[2] if len(self.parent_pac_id.split('-')) > 2 else 'XX'}"
        
        self.wrap = OrchestrationWRAP(
            wrap_id=wrap_id,
            parent_pac_id=self.parent_pac_id,
            maeg_id=self.maeg.maeg_id,
            pdo_orch_id=self.pdo_orch.pdo_orch_id,
            orchestration_type="MULTI_AGENT",
            agent_count=self.maeg.get_agent_count(),
            sub_pacs=sub_pac_summary,
            pdo_orch_hash=self.pdo_orch.pdo_orch_hash,
            merkle_root=self.pdo_orch.merkle_root,
        )
        
        self.status = OrchestrationStatus.COMPLETE
        
        self._log_event("WRAP_EMITTED", {
            "wrap_id": wrap_id,
            "pdo_orch_id": self.pdo_orch.pdo_orch_id,
            "agent_count": self.wrap.agent_count,
            "merkle_root": self.wrap.merkle_root,
        })
        
        return self.wrap
    
    # ────────────────────────────────────────────────────────────────────────
    # Convenience Methods
    # ────────────────────────────────────────────────────────────────────────
    
    def get_orchestration_summary(self) -> dict[str, Any]:
        """Get a summary of the orchestration state."""
        return {
            "status": self.status.value,
            "parent_pac_id": self.parent_pac_id,
            "maeg_id": self.maeg.maeg_id if self.maeg else None,
            "agent_count": self.maeg.get_agent_count() if self.maeg else 0,
            "sub_pacs_generated": len(self.sub_pacs),
            "bers_generated": len(self.bers),
            "pdos_generated": len(self.pdos),
            "pdo_orch_finalized": self.pdo_orch.ready_for_wrap if self.pdo_orch else False,
            "wrap_emitted": self.wrap is not None,
            "completed_nodes": list(self.maeg.completed_nodes) if self.maeg else [],
            "failed_nodes": list(self.maeg.failed_nodes) if self.maeg else [],
        }
    
    def to_dict(self) -> dict[str, Any]:
        """Convert the entire orchestration state to dictionary."""
        return {
            "orchestrator_version": self.VERSION,
            "status": self.status.value,
            "parent_pac_id": self.parent_pac_id,
            "maeg": self.maeg.to_dict() if self.maeg else None,
            "sub_pacs": {k: v.to_dict() for k, v in self.sub_pacs.items()},
            "bers": {k: v.to_dict() for k, v in self.bers.items()},
            "pdos": {k: v.to_dict() for k, v in self.pdos.items()},
            "pdo_orch": self.pdo_orch.to_dict() if self.pdo_orch else None,
            "wrap": self.wrap.to_dict() if self.wrap else None,
            "dispatch_tokens": self.dispatch_tokens,
            "event_log": self.event_log,
        }
