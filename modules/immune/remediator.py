"""
ChainBridge Remediation Engine
==============================

PAC-SYS-P160-IMMUNE-INIT: The Self-Healing Core.

The Remediation Engine transforms the Trinity Gates from passive checkpoints
to intelligent healers. When a transaction fails, this engine:

1. Diagnoses the failure (which gate, what error)
2. Searches for applicable remediation strategies
3. Generates a RemediationPlan (or escalates to human)
4. Executes the fix and enables retry

Invariants:
    - INV-SYS-001: Human-in-the-Loop Fallback
    - INV-SYS-002: No Auto-Approval (fix inputs, never bypass gates)

Author: Benson (GID-00)
Classification: SYSTEM_EVOLUTION
"""

from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from datetime import datetime, timezone
from enum import Enum
from typing import Any, Dict, List, Optional, Type
import hashlib
import json


class EscalationLevel(Enum):
    """Escalation levels for remediation failures."""
    NONE = "none"              # Successfully remediated
    LOW = "low"                # Minor issue, logged only
    MEDIUM = "medium"          # Requires review within 24h
    HIGH = "high"              # Requires immediate human attention
    CRITICAL = "critical"      # System halt, executive escalation


@dataclass
class RemediationResult:
    """Result of a remediation attempt."""
    success: bool
    strategy_used: str
    original_error: str
    corrected_data: Optional[Dict[str, Any]] = None
    explanation: str = ""
    confidence: float = 0.0  # 0.0 to 1.0
    execution_time_ms: float = 0.0
    
    def to_dict(self) -> Dict[str, Any]:
        return {
            "success": self.success,
            "strategy_used": self.strategy_used,
            "original_error": self.original_error,
            "corrected_data": self.corrected_data,
            "explanation": self.explanation,
            "confidence": self.confidence,
            "execution_time_ms": self.execution_time_ms
        }


@dataclass
class RemediationPlan:
    """
    Action plan for correcting transaction errors.
    
    A plan is generated by the RemediationEngine after diagnosing a failure.
    It contains the strategies to attempt and the expected outcome.
    """
    plan_id: str
    failed_gate: str
    error_code: str
    error_message: str
    strategies_to_try: List[str] = field(default_factory=list)
    can_remediate: bool = False
    estimated_success_rate: float = 0.0
    escalation_level: EscalationLevel = EscalationLevel.HIGH
    created_at: str = field(default_factory=lambda: datetime.now(timezone.utc).isoformat())
    
    # Execution state
    executed: bool = False
    result: Optional[RemediationResult] = None
    
    def to_dict(self) -> Dict[str, Any]:
        return {
            "plan_id": self.plan_id,
            "failed_gate": self.failed_gate,
            "error_code": self.error_code,
            "error_message": self.error_message,
            "strategies_to_try": self.strategies_to_try,
            "can_remediate": self.can_remediate,
            "estimated_success_rate": self.estimated_success_rate,
            "escalation_level": self.escalation_level.value,
            "created_at": self.created_at,
            "executed": self.executed,
            "result": self.result.to_dict() if self.result else None
        }


class RemediationStrategy(ABC):
    """
    Abstract base class for remediation strategies.
    
    Each strategy handles a specific type of error and knows how to fix it.
    Strategies are pluggable - new ones can be added without modifying the engine.
    
    Example implementations (future PACs):
        - MissingFieldStrategy: Fills in missing required fields from context
        - FormatCorrectionStrategy: Fixes date/currency/phone formats
        - WatchlistClearanceStrategy: Initiates manual review workflow
        - DocumentRetryStrategy: Requests re-upload of failed documents
    """
    
    @property
    @abstractmethod
    def strategy_id(self) -> str:
        """Unique identifier for this strategy."""
        pass
    
    @property
    @abstractmethod
    def handles_gates(self) -> List[str]:
        """List of gate IDs this strategy can handle (e.g., ['P65', 'P85'])."""
        pass
    
    @property
    @abstractmethod
    def handles_errors(self) -> List[str]:
        """List of error codes this strategy can handle."""
        pass
    
    @abstractmethod
    def can_handle(self, gate: str, error_code: str, context: Dict[str, Any]) -> bool:
        """
        Determine if this strategy can handle the given error.
        
        Args:
            gate: The gate that failed (e.g., 'biometric', 'aml', 'customs')
            error_code: The specific error code
            context: Additional context about the failure
            
        Returns:
            True if this strategy can attempt remediation
        """
        pass
    
    @abstractmethod
    def estimate_success(self, gate: str, error_code: str, context: Dict[str, Any]) -> float:
        """
        Estimate the probability of successful remediation.
        
        Returns:
            Float between 0.0 and 1.0
        """
        pass
    
    @abstractmethod
    def execute(self, original_data: Dict[str, Any], context: Dict[str, Any]) -> RemediationResult:
        """
        Attempt to fix the error.
        
        Args:
            original_data: The original transaction data that failed
            context: Additional context (error details, gate state, etc.)
            
        Returns:
            RemediationResult with success status and corrected data
        """
        pass


class RemediationEngine:
    """
    The Self-Healing Core of ChainBridge v2.0.
    
    The RemediationEngine orchestrates the immune system. It:
    1. Accepts failed TransactionReceipts
    2. Diagnoses the failure
    3. Searches for applicable strategies
    4. Generates and optionally executes a RemediationPlan
    
    Invariants Enforced:
        - INV-SYS-001: Human-in-the-Loop Fallback
        - INV-SYS-002: No Auto-Approval
    
    Usage:
        engine = RemediationEngine()
        engine.register_strategy(MyCustomStrategy())
        
        plan = engine.diagnose(failed_receipt)
        if plan.can_remediate:
            result = engine.execute_plan(plan, original_data)
    """
    
    def __init__(self):
        self._strategies: Dict[str, RemediationStrategy] = {}
        self._execution_log: List[Dict[str, Any]] = []
        self._stats = {
            "diagnoses": 0,
            "remediations_attempted": 0,
            "remediations_successful": 0,
            "escalations": 0
        }
    
    def register_strategy(self, strategy: RemediationStrategy) -> None:
        """
        Register a remediation strategy with the engine.
        
        Strategies are matched to failures based on gate and error code.
        Multiple strategies can handle the same error - they're tried in
        order of estimated success rate.
        """
        self._strategies[strategy.strategy_id] = strategy
    
    def unregister_strategy(self, strategy_id: str) -> bool:
        """Remove a strategy from the engine."""
        if strategy_id in self._strategies:
            del self._strategies[strategy_id]
            return True
        return False
    
    def list_strategies(self) -> List[str]:
        """List all registered strategy IDs."""
        return list(self._strategies.keys())
    
    def diagnose(self, failed_receipt: Dict[str, Any]) -> RemediationPlan:
        """
        Diagnose a failed transaction and generate a remediation plan.
        
        Args:
            failed_receipt: The TransactionReceipt from a failed transaction.
                           Must contain 'status', 'gates', and 'blame' fields.
        
        Returns:
            RemediationPlan with strategies to try or escalation directive
        """
        self._stats["diagnoses"] += 1
        
        # Extract failure information
        status = failed_receipt.get("status", "UNKNOWN")
        blame = failed_receipt.get("blame", {})
        gates = failed_receipt.get("gates", {})
        
        # Find the failed gate
        failed_gate = blame.get("gate", "unknown")
        error_code = blame.get("code", "UNKNOWN_ERROR")
        error_message = blame.get("reason", "No error message provided")
        
        # Generate plan ID
        plan_id = self._generate_plan_id(failed_receipt)
        
        # Find applicable strategies
        context = {
            "receipt": failed_receipt,
            "gates": gates,
            "blame": blame
        }
        
        applicable_strategies = []
        for strategy in self._strategies.values():
            if strategy.can_handle(failed_gate, error_code, context):
                success_estimate = strategy.estimate_success(failed_gate, error_code, context)
                applicable_strategies.append((strategy.strategy_id, success_estimate))
        
        # Sort by estimated success (highest first)
        applicable_strategies.sort(key=lambda x: x[1], reverse=True)
        
        # Determine if we can remediate
        can_remediate = len(applicable_strategies) > 0
        estimated_success = applicable_strategies[0][1] if applicable_strategies else 0.0
        
        # Determine escalation level
        if can_remediate and estimated_success > 0.7:
            escalation = EscalationLevel.NONE
        elif can_remediate and estimated_success > 0.3:
            escalation = EscalationLevel.LOW
        elif can_remediate:
            escalation = EscalationLevel.MEDIUM
        else:
            escalation = EscalationLevel.HIGH
            self._stats["escalations"] += 1
        
        return RemediationPlan(
            plan_id=plan_id,
            failed_gate=failed_gate,
            error_code=error_code,
            error_message=error_message,
            strategies_to_try=[s[0] for s in applicable_strategies],
            can_remediate=can_remediate,
            estimated_success_rate=estimated_success,
            escalation_level=escalation
        )
    
    def execute_plan(
        self, 
        plan: RemediationPlan, 
        original_data: Dict[str, Any]
    ) -> RemediationResult:
        """
        Execute a remediation plan.
        
        Tries strategies in order until one succeeds or all fail.
        
        INVARIANT: This method NEVER approves a transaction. It only
        returns corrected data for RE-SUBMISSION through the gates.
        
        Args:
            plan: The RemediationPlan from diagnose()
            original_data: The original transaction data
            
        Returns:
            RemediationResult with success status and corrected data
        """
        self._stats["remediations_attempted"] += 1
        
        if not plan.can_remediate:
            return RemediationResult(
                success=False,
                strategy_used="none",
                original_error=plan.error_message,
                explanation="No applicable remediation strategy found. Escalating to human.",
                confidence=0.0
            )
        
        context = {
            "plan": plan.to_dict(),
            "failed_gate": plan.failed_gate,
            "error_code": plan.error_code
        }
        
        # Try each strategy in order
        for strategy_id in plan.strategies_to_try:
            strategy = self._strategies.get(strategy_id)
            if not strategy:
                continue
            
            try:
                result = strategy.execute(original_data, context)
                
                # Log the attempt
                self._log_execution(plan, strategy_id, result)
                
                if result.success:
                    self._stats["remediations_successful"] += 1
                    plan.executed = True
                    plan.result = result
                    return result
                    
            except Exception as e:
                # Strategy failed - try next one
                self._log_execution(plan, strategy_id, RemediationResult(
                    success=False,
                    strategy_used=strategy_id,
                    original_error=plan.error_message,
                    explanation=f"Strategy raised exception: {str(e)}",
                    confidence=0.0
                ))
                continue
        
        # All strategies failed
        plan.executed = True
        plan.result = RemediationResult(
            success=False,
            strategy_used="all_failed",
            original_error=plan.error_message,
            explanation="All remediation strategies exhausted. Escalating to human.",
            confidence=0.0
        )
        
        return plan.result
    
    def get_stats(self) -> Dict[str, Any]:
        """Get engine statistics."""
        success_rate = 0.0
        if self._stats["remediations_attempted"] > 0:
            success_rate = (
                self._stats["remediations_successful"] / 
                self._stats["remediations_attempted"]
            )
        
        return {
            **self._stats,
            "success_rate": success_rate,
            "strategies_registered": len(self._strategies)
        }
    
    def get_execution_log(self) -> List[Dict[str, Any]]:
        """Get the execution log for audit purposes."""
        return self._execution_log.copy()
    
    def _generate_plan_id(self, receipt: Dict[str, Any]) -> str:
        """Generate a unique plan ID from receipt data."""
        data = json.dumps(receipt, sort_keys=True)
        timestamp = datetime.now(timezone.utc).isoformat()
        hash_input = f"{data}:{timestamp}"
        return f"PLAN-{hashlib.sha256(hash_input.encode()).hexdigest()[:12].upper()}"
    
    def _log_execution(
        self, 
        plan: RemediationPlan, 
        strategy_id: str, 
        result: RemediationResult
    ) -> None:
        """Log a remediation execution for audit trail."""
        entry = {
            "timestamp": datetime.now(timezone.utc).isoformat(),
            "plan_id": plan.plan_id,
            "failed_gate": plan.failed_gate,
            "error_code": plan.error_code,
            "strategy_used": strategy_id,
            "success": result.success,
            "explanation": result.explanation,
            "confidence": result.confidence
        }
        self._execution_log.append(entry)


# =============================================================================
# SCAFFOLD COMPLETE
# =============================================================================
# 
# The RemediationEngine is now defined with:
#   - RemediationStrategy ABC for pluggable fixes
#   - RemediationPlan for tracking fix attempts
#   - RemediationResult for execution outcomes
#   - Full audit logging
#   - Statistics tracking
#
# NEXT PACs will implement concrete strategies:
#   - P161: MissingFieldStrategy
#   - P162: FormatCorrectionStrategy
#   - P163: DocumentRetryStrategy
#   - P164: WatchlistClearanceWorkflow
#
# Attestation: MASTER-BER-P160-INIT
# Ledger: ATTEST: IMMUNE_SYSTEM_BORN
# =============================================================================
